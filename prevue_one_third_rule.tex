\documentclass{article}
\usepackage{amsmath}
\usepackage[noend]{sources_Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{definition}{Définition}
\setlength{\parskip}{0.22cm}
%\newcommand{\st0}{q^0}

\title{Preuve de correction de l'algorithme One-Third Rule avec départs asynchrones}
\date{4 mai 2020}
\author{Louis Penet de Monterno}

\begin{document}

\maketitle
  
\section{Généralités}

\subsection{Définition générique d'un algorithme HO}

On se donne un ensemble non vide $\Pi$ de cardinalit\'e $n$ et  un ensemble non vide ${\cal M}$ dont les \'el\'ements seront appel\'es des
	messages et un \'el\'ement particulier {\em nil} qui n'est pas dans $\mathcal{M}$.
A chaque  $p \in \Pi$,  on associe  un {\em processus} consistant en la donn\'ee des \'el\'ements 
	suivants :
	\begin{itemize}
	\item un ensemble non vide $States_p$ et un  \'el\'ement $sleep_p \notin state_p$ ;
	\item un sous-ensemble   $Init_p \subseteq state_p$ ;
	\item une fonction $S_p : States_p \rightarrow \Pi \rightarrow \mathcal{M}$ ;
	\item une fonction 
	  $T_p : state_p \rightarrow (\Pi \rightarrow (1 \oplus \{ nil \} \oplus \mathcal{M}))
	  \rightarrow state_p$,
	  où $\Pi \rightarrow (1 \oplus \{ nil \} \oplus \mathcal{M})$ est le type d'une fonction partielle
		de type $\Pi \rightarrow M$, pouvant prendre la valeur supplémentaire notée $nil \notin \mathcal{M}$.
	\end{itemize}
Les \'el\'ements de 	$States_p$  sont appel\'es \emph{\'etats} de $p$, ceux de $Init_p$ \emph{\'etats initiaux} de $p$,
	la fonction $S_p$ est appel\'ee \emph{fonction d'émission de} $p$ et la fonction $T_p$ \emph{fonction de transition de} $p$.

\begin{definition}\label{def:algo}
Un algorithme  sur $\Pi$ est la donn\'ee d'un processus $(States_p, Init_p, S_p,T_p)$ pour chaque  \'el\'ement $p \in \Pi$.
\end{definition}
\noindent Dans toute la suite, on confondra et notera de la m\^eme mani\`ere $p$ et le processus qui lui est associ\'e.

\subsection{Définition générique d'une exécution}

Dans le mod\`ele Heard-Of, le calcul \'evolue en \emph{round} : dans chaque round $r$, 
	le processus $p$, s'il est actif,  
	\begin{enumerate}
	\item \'emet, \`a destination de chaque processus, un message qui est d\'etermin\'e par sa fonction d'\'emission~$S_p$  
		appliqu\'ee \`a son \'etat courant ;
	\item re\c{c}oit un message, \'emis au round $r$, d'un sous-ensemble de processus $HO(p,r)$ de $\Pi$ ;
        \item  applique la fonction  $T_p$ \`a son \'etat courant  et au vecteur (partiel) form\'e par les messages re\c{c}us (dont le support est 
         $HO(p,r)$).
	\end{enumerate}
Si le processus $p$ est passif au round~$r$ alors il \'emet le message $nil$ et reste dans l'\'etat $sleep_p$.
Un processus ne peut devenir actif qu'au d\'ebut d'un round, auquel cas son \'etat passe de $sleep_p$ \`a 
	un \'etat de $Init_p$.
La donn\'ee de l'ensemble $HO(p,r)$ pour chaque processus $p \in \Pi$ est \'equivalente \`a celle du graphe dirig\'e
	$\mathds{G}_r = (\Pi, E_r)$ dont l'ensemble des n\oe uds est $\Pi$ et dont l'ensemble $E_r$ des arcs dirig\'es 
	est d\'efini par
	$$ (q,p) \in E_r \Leftrightarrow q \in HO(p,r) .$$	
Le graphe $\mathds{G}_r $ correspond exactement aux communications entre processus au round~$r$.
Nous ne discutons pas ici des raisons de l'absence de communication de $q$ vers $p$ \`a un round et reportons pour cela  le lecteur 
	\`a~\cite{CB09} dans le cas d'un syst\`eme avec des pannes b\'enignes.

Formellement, une \emph{ex\'ecution} de l'algorithme  $(States_p, Init_p, S_p,T_p)_{p\in \Pi}$ est 
	un triplet $\big( \mathds{G}_r) ,  \mathcal{A}_r) , (\sigma^0_p)_{p \in \Pi} \big)$ où :
	\begin{itemize}
	\item $\mathds{G}$ est un \emph{graphe dynamique} sur $\Pi$, i.e., une suite infinie de graphes dirig\'es 
	$\mathds{G}_r = (\Pi, E_r)$ dont l'ensemble des n\oe uds est $\Pi$ ; 
	\item $\mathcal{A} = (\mathcal{A}_r)_{r \in \mathds{N}}$ est une suite croissante de sous-ensembles de $\Pi$ 
	avec $\mathcal{A}_0 = \emptyset$ ;
	\item pour chaque processus $p\in \Pi$, $\sigma^0_p \in Init_p$.
	\end{itemize}
Ici,  $\mathcal{A}_r \subseteq \Pi$ modélise le sous-ensemble des processus actifs au round~$r$.
La suite est croissante car, l'\'etat actif est stable : une fois r\'eveill\'e, un processus reste actif pour toujours.

\textbf{Remarques :}
\begin{itemize}
	\item Les départs sont synchones lorsque tous les processus deviennent actifs au même round, i.e.,
	$$ \forall r \in \mathds{N}, \mathcal{A}_r \in \{\emptyset, \Pi\}  . $$
	\item La donn\'ee de la suite $(\mathcal{A}_r)_{r \in \mathds{N}}$ est  équivalente \`a celle de la fonction 
	$s : \Pi \rightarrow \mathds{N} \cup \{\infty\}$ où 
	$$ s(p) = \left \{ \begin{array}{l ll}
	                          \infty & \mbox{ si  } p \notin \cup_{r \in \mathds{N}}  \mathcal{A}_r &  \mbox { ($p$ reste passif) } \\
	                          r  & \mbox{ si  } p \notin \mathcal{A}_{r-1} \mbox{ et } p \in \mathcal{A}_{r}  & \mbox{ ($p$ devient actif au round $r$)}.
	                          \end{array} \right.$$ 
	\item On note $HO(p,n)$ l'ensemble des processus actifs entendus par le processus p au round n : $HO(p,n) = \{q, (q,p) \in E_n\}$
	\item On note $HO_{actif}(p,n)$ l'ensemble des processus actifs entendus par le processus p au round n : $HO_{actif}(p,n) = HO(p,n) \cap \mathcal{A}_n$.

\end{itemize}

Pour toute  exécution de l'algorithme  $(States_p, Init_p, S_p,T_p)_{p\in \Pi}$, on définit inductivement la collection 
	d'\'etats $ \big( \Gamma_p(r) \big )_{p\in\Pi, r\in \mathds{N}}$ de la fa\c{c}on suivante : 
	\begin{itemize}
		\item $\forall r \in \mathds{N},\forall p \in \Pi \setminus \mathcal{A}_{r+1}, \  \Gamma_p(r) = sleep_p$ ;
		\item $\forall r  \in \mathds{N},\forall p \in \mathcal{A}_{r+1} \setminus \mathcal{A}_r, \ \Gamma_p(r) = \sigma^0_p$ ;
		\item $\forall r  \in \mathds{N},\forall p \in \mathcal{A}_{r} , \  \Gamma_p(r) = T_p (\Gamma_p(r - 1) ,M_p^{r})$
			où $M_p^r$ est la fonction partielle de type $\Pi \rightarrow (1 \oplus \{ nil \} \oplus \mathcal{M})$ définie par 
			$$ M_p^r = \left \{ \begin{array}{l l}
	                         nil  & \mbox{ si  } q \in (\Pi \setminus \mathcal{A}_r  ) \cap  HO(p,r)  \\
	                         S_q (\Gamma_q(r), p)  & \mbox{ si  }   q \in \mathcal{A}_r  \cap  HO(p,r) \\
	                         \mbox{ non d\'efini  } & \mbox{ si  }   q \notin  HO(p,r) .
	                          \end{array} \right.$$ 
	\end{itemize}
Dorénavant, $M_p^r$ est appelée \emph{fonction de réception de $p$ au round $r$}.

\subsection{Probl\`eme du Consensus}

On considère un algorithme $A$ muni d'une fonction
	$Dec : \bigcup\limits_{p \in \Pi} state_p  \rightarrow (\mathcal{V} \cup \{\bot\})$ 
	où $\mathcal{V}$ est un ensemble non vide tel que $\bot \notin \mathcal{V} $.

\begin{definition}
	Une exécution de A \emph{vérifie  l'intégrité} si 
	$$ \forall r \in \mathds{N},\forall p \in \mathcal{A}_{r}, \ Dec(\Gamma_p(r)) \in \{ \bot \} \cup  \{ \sigma^0_q :  q \in \Pi \}  .$$
\end{definition}

\begin{definition}
	Une exécution de A  \emph{vérifie l'accord} si
	$$\forall r, r'  \in \mathds{N}, \forall p \in \mathcal{A}_{r}, \forall q \in \mathcal{A}_{r'}, 
		\ Dec(\Gamma_p(r)) = \bot \vee Dec(\Gamma_q(r')) = \bot \vee Dec(\Gamma_p(r)) = Dec(\Gamma_q(r')) .$$
\end{definition}

\begin{definition}
	Une exécution de A \emph{vérifie la terminaison} si
	$$ \forall p \in \bigcup\limits_{s \in \mathds{N}} \mathcal{A}_s, \exists r \in \mathds{N}, \ 
		p \in \mathcal{A}_r \wedge Dec(\Gamma_p(r)) \neq \bot .  $$
\end{definition}

On consid\`ere une famille non vide ${\cal G}$ de graphes dynamiques comme d\'efinis ci-dessus
	ou, de fa\c{c}on \'equivalente un pr\'edicat de communication. % A introduire avant ?
	
\begin{definition}
	Un algorithme \emph{résout fortement le consensus dans ${\cal G}$} si toute exécution 
	$( \mathds{G} ,  \mathcal{A} , (\sigma^0_p)_{p \in \Pi})$    de cet algorithme
	avec $ \mathds{G} \in {\cal G}$  vérifie l'intégrité, l'accord et la terminaison.
\end{definition}

\begin{definition}
	Un algorithme \emph{résout faiblement le consensus dans ${\cal G}$} si toute exécution 
	$( \mathds{G} ,  \mathcal{A} , (\sigma^0_p)_{p \in \Pi})$     de cet algorithme  avec
	$ \mathds{G} \in {\cal G}$  et des d\'eparts synchrones, i.e., 
	$$ \forall r \in \mathds{N}, \  \mathcal{A}_r \in \{\emptyset, \Pi\}  ,$$ 
	vérifie l'intégrité, l'accord et la terminaison.
\end{definition}

\section{Algorithme "one-third rule"}
\subsection{Définition de l'algorithme}

Étant donné V un ensemble totalement ordonné, on définit l'algorithme "one-third rule" de la façon suivante.
\begin{itemize}
	\item Pour tout processus p, on pose $state_p = V \times (V \cup \{ \bot \})$.
	On définit les notations suivantes :
	\begin{itemize}

		\item $x : state_p \rightarrow V$ est la première projection.
		\item $dec : state_p \rightarrow V \cup \{\bot\}$ est la seconde projection. La fonction $Dec$ associée à l'algorithme "one-third rule" est définie par cette fonction $dec$.

	\end{itemize}
\item Pour tout processus p, on pose $Init_p = V \times \{ \bot \}$. Cet ensemble correspond à l'ensemble des états pour lesquels aucun décision n'a encore été prise.
\item L'ensembe des message possible est V. 
\item Les fonctions de transition et d'émission sont définies par les pseudo-code ci-dessous.
\end{itemize}
Pour toute fonction $M$, on note $Im M$ la fonction définie par $(Im M)(v) = |M^{-1}(v)|$. Ainsi $(Im M)(v)$ est le nombre d'occurrence du message v parmi un vecteur de messages.
On note également $min \{M^{-1} (max (Im M)\}$  le minimum parmi les messages les plus fréquents.

\begin{algorithm}[htb]
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
  \STATE $x_p :=\, v_p$ \COMMENT{  $v_p$ est la valeur initiale de $p$ }
  \STATE $dec_p :=\, \bot$ 
%  \STATE $vote_p \in V\cup\{ ? \}$, initially $?$

\ENDINDENT \BLANK

\INDENT{\textbf{Round $r$:}}
 \INDENT{$S^r_p:$}
    \STATE send $\langle\, x_p\, \rangle$ to all processes
  \ENDINDENT
  \BLANK
	\INDENT{$T^r_p(M):$}
	\IF{$|HO_{actif}(p,r)| > 2\mathcal{N}/3 $}
	\STATE $M(nil) := 0$ \COMMENT{les $nil$ sont ignorés}
	  \STATE $x_p := min \{M^{-1} (max (Im M))\}$ \COMMENT{la valeur minimale parmi les $x$ les plus fréquents reçus des processus actifs}
		\IF{$M(x_p) > 2\mathcal{N}/3$} 
		  \STATE $dec_p := x_p$ \COMMENT{plus de $2\mathcal{N}/3$ des valeurs reçues valent $x_p$}
        \ENDIF
      \ENDIF
  \ENDINDENT
\ENDINDENT \BLANK


\caption{The {\em OneThirdRule} algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

\textbf{Notation :} Pour toute exécution de l'algorithme, on introduit
\begin{itemize}

	\item $x_p(n)$ et $dec_p(n)$ non définis si $\Gamma_p(n) = sleep_p$. Sinon ...
	\item $x_p(n) = x(\Gamma_p(n))$
	\item $dec_p(n) = dec(\Gamma_p(n))$

\end{itemize}

\subsection{Intégrité}

\begin{theorem}
	Toute exécution de l'algorithme vérifie l'intégrité.
\end{theorem}
\begin{proof}
	Soit une exécution quelquonque de l'algorithme donnée. Cette exécution fixe donc $\mathds{G}$, $(\mathcal{A}_n)_{n \in \mathds{N}}$, $\Gamma$ et $(\sigma^0_p)_{p \in \Pi}$ de manière univoque.
	On montre d'abord par récurrence sur n l'invariant suivant : 

	$  \forall n \in \mathds{N}, \forall p \in \mathcal{A}_{n+1}, x_p(n) \in x_{init}$

\textbf{Intialisation}
	Triviale, car $p \in \mathcal{A}_1 \Rightarrow x_p(0) = \sigma^0_p$. 

\textbf{Hérédité}
	Pour un n donné, on suppose $\forall p \in \mathcal{A}_{n+1}, x_p(n) \in x_{init}$.
Soit $q \in \mathcal{A}_{n+2}$ . On distingue les deux cas suivants :
\begin{itemize}
	\item $q \notin \mathcal{A}_{n+1}$. Dans ce cas, $x_p(n+1) = \sigma^0_p$.
	\item $|HO_{actif} (q, n+1) | \leq \frac{2\mathcal{N}}{3}$. Dans ce cas, $x_q(n+1) = x_q(n)$. L'hypothèse de récurrence permet de prouver l'invariant.
	\item $|HO_{actif} (q, n+1) | >    \frac{2\mathcal{N}}{3}$. Dans ce cas, $x_q(n+1) = min \{M^{-1} (max (Im M))\}\}$. On applique l'hypothèse de récurrence au processus qui atteint ce minimum.
		Cela prouve l'invariant.

\end{itemize}

L'intégrité découle naturellement de cet invariant, car, lorsqu'un processus décide, $x_p = dec_p$.
\end{proof}

\subsection{Accord}

Soit une exécution de l'algorithme.
La preuve de l'accord des exécutions de l'algorithme est construite à partir d'une série de lemmes.

\begin{lemma}

	Si, pour $p \in \mathcal{A}_{n+1}$ , $x \in V$ et $n \in \mathds{N}$, 

\begin{itemize}

	\item $| HO_{active} (p,n+1) | > \frac{2\mathcal{N}}{3}$
	\item $| \{ q \in \mathcal{A}_{n+1} , x_q(n) = x \} | > \frac{2\mathcal{N}}{3}$.

\end{itemize}

On montre que $x_p(n+1) = x$

\end{lemma}

\begin{proof}

	Soit $M$ la fonction de réception des messages de p au round n+1. On note $M^{-1}(x)$ l'ensemble des processus ayant émis $x$, et dont le message est parvenu à $p$.

	On a
\begin{equation}
\begin{split}
	HO_{active}(p, n+1) & = M^{-1}(x) \cup (HO_{active}(p, n+1) \setminus M^{-1}(x)) \\
	& \subseteq M^{-1}(x) \cup \{ q \in \mathcal{A}_{n+1} , x_q(n) \neq x \}
\end{split}
\end{equation}

Ainsi 
\begin{equation}
\begin{split}
\frac{2\mathcal{N}}{3} & < | HO_{active}(p, n+1) | \\
		& \leq | M^{-1}(x) | + | \{ q \in \mathcal{A}_{n+1} , x_q(n) \neq x \} | \\
		& \leq | M^{-1}(x) | +  \frac{\mathcal{N}}{3} \\
\end{split}
\end{equation}


	Ainsi
\begin{equation}
\begin{split}
| M^{-1}(x) | & > \frac{\mathcal{N}}{3} \\
		& \geq | \{ q \in \mathcal{A}_{n+1} , x_q(n) \neq x \} | \\
		& \geq | HO_{active}(p,n+1) \setminus M^{-1}(x) | \\
\end{split}
\end{equation}

Donc $x$ est l'élément le plus fréquent de M. Donc $x_p(n+1) = x$.

\end{proof}

\begin{lemma}

Toute supermajorité (ie. plus de deux tiers des processus) de valeurs se conserve :

	$\forall k \in \mathds{N}, | \{ q \in \mathcal{A}_{n+1} , x_q(n) = x \} | > \frac{2\mathcal{N}}{3} \Rightarrow | \{ q \in \mathcal{A}_{n+k+1} , x_q(n+k) = x \} | > \frac{2\mathcal{N}}{3}$.

\end{lemma}

\begin{proof}

Soit $p \in  \{ q \in \mathcal{A}_{n+1} , x_q(n) = x \} $. On distingue les cas suivants :

\begin{itemize}

\item $|HO_{actif} (p, n+1) | \leq \frac{2\mathcal{N}}{3}$. Dans ce cas, $x_p(n+1) = x_p(n) = x$.
\item $|HO_{actif} (p, n+1) | > \frac{2\mathcal{N}}{3}$. Dans ce cas, le lemme 1 permet de montrer que $x_p(n+1) = x$.

\end{itemize}
Dans tous les cas 
	$p \in \{ q \in \mathcal{A}_{n+1} , x_q(n+1) = x \} $.

	La suite $(\{ q \in \mathcal{A}_{n+1} , x_q(n+k) = x \})_{k \in \mathds{N}}$ est donc croissante selon l'ordre d'inclusion ensembliste. Cela prouve le lemme.
\end{proof}
\begin{lemma}
	$\forall x \in V, \forall n k \in \mathds{N}, \forall p \in \mathcal{A}_n, dec_p(n) = x \Rightarrow| \{ q \in \mathcal{A}_{n+k} , x_q(n+k) = x \} | > \frac{2\mathcal{N}}{3}$
\end{lemma}
\begin{proof}

On montre cela par récurrence sur n.

\textbf{Initialisation}
	Trivial car $\mathcal{A}_0 = \emptyset$.

\textbf{Hérédité}
	Pour $x \in V, p \ \mathcal{A}_n, n \in \mathds{N}$ fixés, on suppose que 
	$ \forall k \in \mathds{N}, dec_p(n) = x \Rightarrow| \{ q \in \mathcal{A}_{n+k} , x_q(n+k) = x \} | > \frac{2\mathcal{N}}{3}$.

	On veut montrer que 
	$ \forall k \in \mathds{N}, dec_p(n+1) = x \Rightarrow| \{ q \in \mathcal{A}_{n+k+1} , x_q(n+k+1) = x \} | > \frac{2\mathcal{N}}{3}$.

	Soit $k \in \mathds{N}$, on suppose que $dec_p(n+1) = x$.

	\begin{itemize}

		\item Si $dec_p(n) = x$, le lemme découle de l'hypothèse de récurrence.
		\item Sinon $dec_p(n) = \bot$. On en déduit que, au round n+1, le processus p avait reçu une fonction de réception $M_p^{n+1}$ telle que $M_p^{n+1}(x) > \frac{2\mathcal{N}}{3}$.
			Donc $| \{ q \in \mathcal{A}_n , x_q(n) = x \} | > \frac{2\mathcal{N}}{3}$.
			On conclut alors en utilisant le lemme 2.

	\end{itemize}
\end{proof}

\begin{lemma}
	Aucune décision ne peut être en conflit avec une décision précédente.
	$ \forall n \in \mathds{N}, k \in \mathds{N}, \forall p \in \mathcal{A}_n, q \in \mathcal{A}_{n+k},dec_p(n) = \bot \vee dec_q(n+k) = \bot \vee dec_p(n) = dec_q(m)$.
\end{lemma}
\begin{proof}

	Si $dec_p(n) = x_1 \neq \bot$,   le lemme 3 montre que $|\{h \in \mathcal{A}_{n+1}, x_h(n+k) = x_1\}| > \frac{2\mathcal{N}}{3}$.

	Si $dec_q(n+k) = x_2 \neq \bot$,   le lemme 3 montre que $|\{h \in \mathcal{A}_{n+k+1}, x_h(n+k) = x_2\}|> \frac{2\mathcal{N}}{3}$.

Ces deux supermajorités se recoupent nécessairement, donc $x_1 = x_2$.
\end{proof}

Ce dernier lemme permet de prouver l'accord de toute exécution de l'algorithme.

\subsection{Terminaison}

On prouve la terminaison pour toute exécution de l'algorithme dont le graphe dynamique actif vérifie les prédicats suivants :
\begin{itemize}
	\item $\forall n \in \mathds{N}, \exists m \in \mathds{N}, \exists S \subseteq \mathcal{A}_m, |S| > \frac{2\mathcal{N}}{3} \wedge m > n \wedge (\forall q \in S, HO_{actif}(q, m) = S)$
	\item $\mathds{G}$ admet infiniment souvent un noyau contenant une supermajorité de processus actifs :
		$\forall n \in \mathds{N}, \exists m \in \mathds{N}, \exists \Pi_0 \subseteq \mathcal{A}_m, |\Pi_0| > \frac{2\mathcal{N}}{3} \wedge m > n \wedge (\forall q \in \Pi, \Pi_0 \subseteq HO_{actif}(q,m))$.
\end{itemize}

\begin{proof}

	Comme $\Pi$ est un ensemble fini, la suite $(\mathcal{A}_n)_{n \in \mathds{N}}$ atteint un maximum à partir d'un certain round n.
	Ainsi $\forall n_0 > n, \mathcal{A}_{n_0} = \mathcal{A}_n$.
	À partir de là, la preuve avec départs asynchrones est identique à celle avec départs synchones. 
	À partir du premier prédicat, on obtient $m > n$ et $S \subseteq \mathcal{A}_n$ tel que :
	\begin{itemize}

		\item $\forall q \in S, HO_{actif}(q, m) = S$
		\item $|S| > \frac{2\mathcal{N}}{3}$

	\end{itemize}

	On en déduit que, pour tout $p \in S$, la fonction de réception $M_p^m$ est définie par :
	\begin{itemize}

		\item $M_p^m(q) = x_q(m-1)$ pour tout $q \in S$
		\item $M_p^m(q)$ non défini sinon

	\end{itemize}

	On a donc, $\forall p q \in S, M_p^m = M_q^m$, donc, d'après la façon dont $T_p$ est construite, $\forall p q \in S, x_p(m) = x_q(m)$.
	À la fin du round m, S constitue donc une supermajorité de processus ayant tous une même valeur pour la variable x, que l'on notera $\overline{x}$

D'après le lemme 2 de la section précédente, cette supermajorité se conserve aux rounds suivants.

	À partir du second prédicat, on obtient $r > m$ et $\Pi_0 \subseteq \mathcal{A}_n$, tels que :
	\begin{itemize}

		\item $\forall q \in \Pi, \Pi_0 \subseteq HO_{actif}(q, m)$
		\item $|\Pi_0| > \frac{2\mathcal{N}}{3}$
		\item On a de plus $\forall p \in S, x_p(r-1) = \overline{x}$

	\end{itemize}

	D'après le lemme 1 de la section précédente, $\forall p \in \mathcal{A}_n, x_p(r) = \overline{x}$.

	Par une récurrence triviale, on montre que  $\forall r_0 > r, \forall p \in \mathcal{A}_n, x_p(r_0) = \overline{x}$.
	On utilise le fait que plus aucun processus ne se réveille, car $r \geq n$.


	À partir du second prédicat, on obtient $r_0 > r$ et $\Pi_1 \subseteq \mathcal{A}_n$, tels que :
	\begin{itemize}

		\item $\forall q \in \Pi, \Pi_1 \subseteq HO_{actif}(q, m)$
		\item $|\Pi_1| > \frac{2\mathcal{N}}{3}$
		\item On a de plus $\forall p \in \mathcal{A}_n, x_p(r_0) = \overline{x}$

	\end{itemize}

	On a donc, $\forall p \in \mathcal{A}_n, \Pi_1 \subseteq (M_p^{r_0})^{-1}(\overline{x}) $
	Donc, $\forall p \in \mathcal{A}_n, |(M_p^{r_0})^{-1}(\overline{x})| > \frac{2\mathcal{N}}{3} $.

	Finalement, $\forall p \in \mathcal{A}_n, dec_p(r_0) = \overline{x}$.

\end{proof}

\section{Conclusion}

Les trois sections précédentes montrent que l'algorithme "one-third rule" assure le consensus :

	\begin{theorem}

		 L'algorithme "one-third rule" asssure le consensus lorsque les prédicats suivants sont vérifiés :
		\begin{itemize}
			\item $\forall n \in \mathds{N}, \exists m \in \mathds{N}, \exists S \subseteq \mathcal{A}_m, |S| > \frac{2\mathcal{N}}{3} \wedge m > n \wedge (\forall q \in S, HO_{actif}(q, m) = S)$
			\item $\mathds{G}$ admet infiniment souvent un noyau contenant une supermajorité de processus actifs.
		\end{itemize}
	\end{theorem}


\end{document}

