\documentclass{article}
\usepackage{amsmath}
\usepackage[noend]{sources_Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{definition}{Définition}

\title{Preuve de correction de l'algorithme One-Third Rule avec départs asynchrones}
\date{4 mai 2020}
\author{Louis Penet de Monterno}

\begin{document}
\maketitle
  
\section{Algorithme}

\subsection{Définition générique d'un algorithme}

\begin{definition}

Un algorithme est un ensemble de processus $\Pi$ auxquels sont associés :

\begin{itemize}

  \item un ensemble d'états actifs $states_p$, ainsi qu'un état passif, noté $sleep_p \notin state_p$.
  \item un ensemble d'états initiaux  $init_p \subseteq state_p$
  \item un ensemble de messages V
  \item pour tout $p \in \Pi$, une fonction d'émission
	  $S_p : states_p \rightarrow \Pi \rightarrow M$
  \item pour tout $p \in \Pi$, une fonction de transition
	  $T_p : state_p \rightarrow (\Pi \rightarrow (1 \oplus \{ nil \} \oplus M))
	  \rightarrow state_p$,
	  où $\Pi \rightarrow (1 \oplus \{ nil \} \oplus M)$ est le type d'une fonction partielle
		de type $\Pi \rightarrow M$, pouvant prendre une valeur supplémentaire notée \textit{nil}.

\end{itemize}
\end{definition}

On note $HO_{actif}(p,n)$ l'ensemble des processus actifs entendus par le processus p au round n.

\subsection{Définition générique d'une exécution}

\begin{definition}

On définit une exécution comme la donnée d'un tuple
$( \mathds{G},  \mathds{G}_A, (in_p)_{p \in \Pi})$ où :

\begin{itemize}

	\item $\mathds{G}$ est le graphe dynamique indexé sur $\mathds{N}$.
	\item $\mathds{G}_A$ est le sous-graphe dynamique de $\mathds{G}$ resteint au processus actifs.
		On note $p \in \mathds{G}_A(n)$ si p est actif au round n.
		$\mathds{G}_A$ vérifie $\forall p \in \Pi,  n \in \mathds{N}, p \in \mathds{G}_A(n) \Rightarrow p \in \mathds{G}_A(n+1)$.
	\item $in_p$ est l'état initial de p, vérifiant $\forall p \in \Pi, in_p \in init_p$.

\end{itemize}
Lorsque les départs sont synchones, les graphes dynamiques $\mathds{G}$ et $\mathds{G}_A$ sont identiques.
\end{definition}

\begin{definition}
	Pour un algorithme donné, une exécution permet de définir inductivement une fonction $\Gamma$ qui,
	pour tout processus p et round n, donne l'état de p au round n : $\Gamma_p(n) \in \{nil\} \cup state_p$
	\begin{itemize}
		\item $\forall p \in \Pi, p \in \mathds{G}_A(0) \Rightarrow \Gamma_p(0) = in_p$.
		\item $\forall p \in \Pi, n \in \mathds{N}, p \notin \mathds{G}_A(n) \Rightarrow \Gamma_p(n) = nil$.
		\item $\forall p \in \Pi, n \in \mathds{N}, p \notin \mathds{G}_A(n) \Rightarrow p \in \mathds{G}_A(n+1) \Rightarrow \Gamma_p(n+1) = in_p$.
		\item $\forall p \in \Pi, n \in \mathds{N}, p \in    \mathds{G}_A(n) \Rightarrow p \in \mathds{G}_A(n+1) \Rightarrow \Gamma_p(n+1) = T_p (\Gamma_p(n) ,M_p^n)$
			où $M_p^n$ est l'ensemble des messages reçus par p.
		\begin{itemize}
			\item $M_p^n(q)$ non défini si $q \notin HO(p, n)$.
			\item $M_p^n(q) = nil$ si $q \notin \mathds{G}_A$
			\item $M_p^n(q) = S_q (\Gamma_q(n), p)$ sinon.
		\end{itemize}

	\end{itemize}
\end{definition}
\subsection{Définition de l'algorithme "one-third rule"}

Étant donné V un ensemble totalement ordonné, on définit l'algorithme "one-third rule" de la façon suivante.
\begin{itemize}
	\item Pour tout processus p, on pose $state_p = V \times (V \cup \{ \bot \})$.
	Si, pour un round n, p est un processus actif, on définit les notations suivantes :
	\begin{itemize}

		\item $x_p(n)$ est la première composante de l'état du processus.
		\item $dec_p(n)$ est sa deuxième composante. Cette composante détermine la valeur de décision 
		du processus, valant $\bot$ s'il n'a pas décidé.

	\end{itemize}
\item Pour tout processus p, on pose $init_p = V \times \{ \bot \}$. Cet ensemble correspond à l'ensemble des états pour lesquels aucun décision n'a encore été prise.
\item L'ensembe des message possible est V. 
\end{itemize}
Pour un ensemble de messages reçus par un processus M, on note $min \{M^{-1} (max M)\}$  le minimum parmi les messages les plus fréquents.
On définit les fonctions d'émission et de transision ci-dessous.

\begin{algorithm}[htb]
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
  \STATE $x_p :=\, v_p$ \COMMENT{  $v_p$ est la valeur initiale de $p$ }
  \STATE $dec_p :=\, \bot$ 
%  \STATE $vote_p \in V\cup\{ ? \}$, initially $?$

\ENDINDENT \BLANK

\INDENT{\textbf{Round $r$:}}
 \INDENT{$S^r_p:$}
    \STATE send $\langle\, x_p\, \rangle$ to all processes
  \ENDINDENT
  \BLANK
  \INDENT{$T^r_p:$}
	\IF{$|HO_{actif}(p,r)| > 2n/3 $}
	  \STATE $x_p := min \{M^{-1} (max M)\}$ \COMMENT{la valeur minimale parmi les $x$ les plus fréquents reçus des processus actifs}
		\IF{$M(x_p) > 2n/3$} 
		  \STATE $dec_p := x_p$ \COMMENT{plus de $2n/3$ des valeurs reçues valent $x_p$}
        \ENDIF
      \ENDIF
  \ENDINDENT
\ENDINDENT \BLANK


\caption{The {\em OneThirdRule} algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

\section{Intégrité}

\begin{definition}
	Une exécution vérifie l'intégrité si, $\forall p \in \Pi, \forall n \in \mathds{N}, dec_p(n) \in \{ \bot \} \cup x_{init}$
	où $x_{init}$ est l'ensemble des valeurs initiales $\{ in_p, p \in \Pi \}$
\end{definition}

\begin{theorem}
	Toute exécution de l'algorithme vérifie l'intégrité.
\end{theorem}
\begin{proof}
On montre d'abord par récurrence sur n l'invariant suivant : 

	$ \forall p \in \Pi, \forall n \in \mathds{N}, x_p(n) \in x_{init}$

\textbf{Intialisation}
Triviale, car $x_p(0) = in_p$. 

\textbf{Hérédité}
	Pour un n donné, on suppose $\forall p \in \Pi, x_p(n) = x \Rightarrow x \in x_{init}$.
Soit $q \in \Pi$ . On distingue les deux cas suivants :
\begin{itemize}

\item $|HO_{actif} (q, n) | \leq \frac{2n}{3}$. Dans ce cas, $x_q(n+1) = x_q(n)$. L'hypothèse de récurrence permet de prouver l'invariant.
\item $|HO_{actif} (q, n) | > \frac{2n}{3}$. Dans ce cas, $x_q(n+1) = min \{M^{-1} (max M)\}\}$. On applique l'hypothèse de récurrence au processus qui atteint ce minimum. Cela prouve l'invariant.

\end{itemize}

L'intégrité découle naturellement de cet invariant, car, lorsqu'un processus décide, $x_p = dec_p$.
\end{proof}

\section{Accord}

\begin{definition}
	Une exécution vérifie l'accord si, pour tout round n et m, pour tout processus p et q, on a $dec_p(m) \neq \bot \Rightarrow deq_q(n) \neq \bot \Rightarrow dec_p(m) = dec_q(n)$.
\end{definition}

La preuve de l'accord des exécutions de l'algorithme est construite à partir d'une série de lemmes.
Quand les départs sont synchones, $HO_{active}$ s'identifie à $HO$ et $\mathds{G}_A$ à $\mathds{G}$, mais la preuve reste essentiellement identique à celle avec départs asynchrones.

\begin{lemma}

	Si, pour p processus, $x \in V$ et $n \in \mathds{N}$, 

\begin{itemize}

\item $| HO_{active} (p,n) | > \frac{2|\Pi|}{3}$
\item $| \{ q \in \mathds{G}_A(n) , x_q(n) = x \} | > \frac{2|\Pi|}{3}$.
\item $p \in \mathds{G}_A(n)$

\end{itemize}

On montre que $x_p(n+1) = x$

\end{lemma}

\begin{proof}

	Soit M l'ensemble des messages reçus par p. On note $M(x)$ l'ensemble des messages valant $x$, et $M(\overline{x})$ l'ensemble complémentaire.

On a $M = M(x) \cup M(\overline{x}) \subseteq M \cup \{ q \in \mathds{G}_A(n) , x_q(n) \neq x \} $

\vspace{0.4cm}

	Ainsi $\frac{2|\Pi|}{3} < | M | = | M(x) | + | M(\overline{x}) | \leq | M(x) | + | \{ q \in \mathds{G}_A(n) , x_q(n) \neq x \} | \leq | M(x) | +  \frac{|\Pi|}{3}$

\vspace{0.4cm}

Ainsi  $| M(x) | > \frac{|\Pi|}{3} \geq | \{ q \in \mathds{G}_A(n) , x_q(n) \neq x \} | \geq | M(\overline{x}) |$

Donc $x$ est l'élément le plus fréquent de M. Donc $x_p(n+1) = x$.

\end{proof}

\begin{lemma}

Toute supermajorité (ie. plus de deux tiers des processus) de valeurs se conserve. Pour tout k entier naturel : 

$| \{ q \in \Pi , x_q(n) = x \} | > \frac{2|\Pi|}{3} \Rightarrow | \{ q \in \Pi , x_q(n+k) = x \} | > \frac{2|\Pi|}{3}$.

\end{lemma}

\begin{proof}

Soit $p \in | \{ q \in \Pi , x_q(n) = x \} | > \frac{2|\Pi|}{3}$. On distingue les cas suivants :

\begin{itemize}

\item $|HO_{actif} (p, n) | \leq \frac{2|\Pi|}{3}$. Dans ce cas, $x_p(n+1) = x_p(n) = x$.
\item $|HO_{actif} (p, n) | > \frac{2|\Pi|}{3}$. Dans ce cas, le lemme 1 permet de montrer que $x_p(n+1) = x$.

\end{itemize}
Dans tous les cas 
$p \in \{ q \in \Pi , x_q(n+1) = x \} > \frac{2|\Pi|}{3}$.

La suite $\{ q \in \Pi , x_q(n+k) = x \}$ est donc croissante selon l'ordre d'inclusion ensembliste. Cela prouve le lemme.
\end{proof}
\begin{lemma}

Soit p un processus. Si p décide $x$ au round n, on en déduit, pour tous les rounds suivants n+k :

$| \{ q \in \Pi , x_q(n+k) = x \} | > \frac{2|\Pi|}{3}$
\end{lemma}
\begin{proof}

On montre cela par récurrence sur n, pour un k arbitraire.

\textbf{Initialisation}
Les processus ne décident jamais au round 0, donc ex falso quodlibet.

\textbf{Hérédité}
Si p avait déjà décidé au round précédent, le lemme découle de l'hypothèse de récurrence.
Sinon, p vient de décider, ce qui signifie d'une part, qu'il était déjà réveillé, et d'autre part
qu'il vient d'entendre une supermajorité de messages contenant la valeur x.
On conclut alors en utilisant le lemme 2.

\end{proof}
\begin{lemma}
	Aucune décision ne peut être en conflit avec une décision précédente.
	$\forall p \in \Pi, q \in \Pi, \forall n \in \mathds{N}, k \in \mathds{N}, dec_p(n) = x_1 \Rightarrow dec_q(n+k) = x_2 \Rightarrow x_1 = x_2$.
\end{lemma}
\begin{proof}

Si p décide $x_1$ au round n,   le lemme 3 montre qu'une supermajorité de processus a $x_1$ comme valeur au round $n+k$.
Si q décide $x_2$ au round n+k, le lemme 3 montre qu'une supermajorité de processus a $x_2$ comme valeur au round $n+k$.

Ces deux supermajorités se recoupent nécessairement, donc $x_1 = x_2$.
\end{proof}

Ce dernier lemme permet de prouver l'accord de toute exécution de l'algorithme.

\section{Terminaison}

\begin{definition}
	Une exécution vérifie la terminaison, si tout processus p qui se réveille atteint, à un certain round n, un état tel que $dec_p(n) \neq \bot$.
\end{definition}

On prouve la terminaison pour toute exécution de l'algorithme dont le graphe dynamique actif vérifie les prédicats suivants :
\begin{itemize}
	\item $\mathds{G}_A$ est infiniment souvent S-uniforme avec un S contenant une supermajorité de processus  :
		$\forall n \in \mathds{N}, \exists m \in \mathds{N}, \exists S \subseteq \mathds{G}_A(m), |S| > \frac{2|\Pi|}{3} \wedge m > n \wedge (\forall q \in HO_{actif}(q, m) = S)$
	\item $\mathds{G}_A$ admet infiniment souvent un noyau contenant une supermajorité de processus :
		$\forall n \in \mathds{N}, \exists m \in \mathds{N}, \exists \Pi_0 \subseteq \mathds{G}_A(m), |\Pi_0| > \frac{2|\Pi|}{3} \wedge m > n \wedge K(m) = \Pi_0$.
\end{itemize}

\begin{proof}

	Comme les processus sont en nombre fini, il existe un round n à partir duquels plus aucun processus ne se réveille.
	À partir de là, la preuve avec départs asynchrones est identique à celle avec départs synchones. 
	À partir du premier prédicat, on obtient un round m S-uniforme, ultérieur à n. Au round m, tous les processus dans S sont actifs et reçoivent un même ensemble M de messages, vérifiant $| M | > \frac{2|\Pi|}{3}$. On a donc, $\forall p \in \Pi, x_p(n+1) = min \{M^{-1} (max M)\}$. On a donc à ce state une supermajorité de processus actifs ayant le même x, noté $\overline{x}$.

D'après le lemme 2 de la section précédente, cette supermajorité se conserve aux rounds suivants.

À partir du second prédicat, on obtient un round r uniforme, ultérieur à m. Au round r, tous les processus actifs reçoivent plus de $\frac{2|\Pi|}{3}$ messages. D'après le lemme 1 de la section précédente, tous les processus ont maintenant $\overline{x}$ comme valeur pour $x$.

	Par une récurrence triviale, on montre que pour tous les rounds ultérieurs à r, tous les processus ont $\overline{x}$ comme valeur.
	On utilise le fait que plus aucun processus ne se réveille, car $r \geq n$.

	À partir du second prédicat, on obtient un round $r_0$ uniforme, ultérieur à r. Au round $r_0$, tous les processus actifs reçoivent une supermajorité de messages, qui valent tous $\overline{x}$. Donc tous les processus actifs décident $\overline{x}$.

\end{proof}

\section{Conclusion}

	\begin{theorem}

		Les trois sections précédentes montrent que l'algorithme "one-third rule" assure le consensus lorsque les prédicats suivants sont vérifiés :
		\begin{itemize}
			\item $\mathds{G}_A$ est infiniment souvent S-uniforme avec un S contenant une supermajorité de processus.
			\item $\mathds{G}_A$ admet infiniment souvent un noyau contenant une supermajorité de processus.
		\end{itemize}
	\end{theorem}


\end{document}
