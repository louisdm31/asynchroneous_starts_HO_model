\documentclass{article}
\usepackage{amsmath}
\usepackage[noend]{sources_Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{definition}{Définition}
\setlength{\parskip}{0.22cm}
%\newcommand{\st0}{q^0}


\title{Algorithme de synchronisation modulo k}
\date{1 juin 2020}
\author{Louis Penet de Monterno}

\begin{document}

\maketitle

\section{Problème}

Il est courant de rencontrer des algorithmes de consensus, structurés par phases : 
à chaque rounds pairs, les processus exécutent une certaine fonction de transition. Et au round impairs, une autre fonction de transition est exécutée.
Lorsque les départs sont synchrones, tous les processus exécutent la même fonction de transition à chaque round.
Lorsqu'il y a des départs asynchrones, les phases paires des différents processus ne sont plus simultanées, et cela peut compromettre la sûreté de l'algorithme.
Le but de ce document est de proposer un algorithme permettant de synchroniser les différentes phases malgré les départs asynchrones.

\begin{definition}

	Soit un paramètre $k > 1$. Soit $s_{exit} \in States_p$ un état final.
	Étant donnée une exécution d'un algorithme $A$, pour tout $p \in \Pi$, on note $t_p$ le round auquel $p$ atteint $s_{exit}$ ($t_p = \infty$ sinon).
	Cette exécution de l'algorithme $A$ est sûr vis à vis du problème de synchronisation modulo $k$ si,
	$$\exists c \in \mathds{N}, \forall p \in \bigcup\limits_{i \in \mathds{N}} \mathcal{A}_i, t_p \neq \infty \Rightarrow t_p~mod~k = c$$

\end{definition}

\begin{definition}

	Une exécution de l'algorithme $A$ vérifie la terminaison vis à vis du problème de synchronisation modulo $k$ si,
	$$\forall p \in \bigcup\limits_{i \in \mathds{N}} \mathcal{A}_i, t_p \neq \infty$$

\end{definition}
\begin{definition}

	L'algorithme $A$ résoud le problème de synchronisation modulo $n$, si toute exécution de $A$ est sûre et termine.

\end{definition}

\section{Algorithme}

L'objectif est de résoudre ce problème dans les conditions suivantes :
\begin{itemize}

	\item Le graphe dynamique contient une étoile fixe : $\mathcal{P}_{nek-fixed} \equiv \exists \xi \in \Pi, \forall p \in \Pi, \forall r \in \mathds{N}, \xi \in HO(p, r)$
	\item Tous les processus s'activent en temps fini : $\mathcal{P}_{non-inf} \equiv \exists r \in \mathds{N}, \mathcal{A}_r = \Pi$

\end{itemize}

L'idée de l'algorithme ci-dessous est que chaque processus possède un compteur modulo $k$. À chaque round, il incrémente son compteur, et l'envoie à tous.
Il reçoit alors les valeurs de compteur de tous ses voisins entrants. Il essaye de se synchroniser avec les autres processus s'ils s'accordent sur une même valeur de compteur.
Sinon, il essaye de convaincre tous les processus de se synchroniser sur son compteur : il adopte la valeur $k-1$. Au prochain round, il envoie $0$.
Les processus qui reçoivent ce $0$ sont obligés de l'adopter. Chaque processus ne fait qu'une seule fois cette tentative de synchronisation active.

\begin{algorithm}[htb]
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
  \STATE $x_p :=\, 0$ 
  \STATE $try_p = true$

\ENDINDENT \BLANK

\INDENT{\textbf{Round $0$:}}
 \INDENT{$S_p:$}
    \STATE send $nil$ to all processes
  \ENDINDENT
\ENDINDENT
  \BLANK
\INDENT{\textbf{Round $r+1$:}}
 \INDENT{$S_p:$}
    \STATE send $x_p+1~mod~n$ to all processes
  \ENDINDENT
\ENDINDENT
  \BLANK
\INDENT{\textbf{Round $r$:}}
	\INDENT{$T_p(M):$}
	\IF{$M(\Pi) = \{0\}$}
	\STATE $EXIT()$ ~~~~\COMMENT{si tous les messages reçus valent $0$, aucun $nil$, l'algorithme termine}
	\ELSIF{$M(\Pi) \setminus \{nil\} = \{v\}$}
	\STATE $x_p = v$ ~~~~\COMMENT{si tous les messages ont la même valeur, s'aligner}
	\ELSIF{$try_p \wedge 0 \notin M(\Pi)$}
	\STATE $try_p = false$
	\STATE $x_p = k - 1$
	\ELSE
	\STATE $x_p = 0$ ~~~~\COMMENT{sinon $x_p$ prend la valeur 0}
	\ENDIF
  \ENDINDENT
\ENDINDENT 
\caption{The {\em SyncMod} algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

\begin{lemma}
	Toute exécution de cet algorithme est sûr vis-à-vis du problème de synchronisation modulo k lorsque les prédicats $\mathcal{P}_{nek-fixed}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{lemma}
\begin{proof}

	Soit $\xi$ le processes au centre de l'étoile.
	On suppose que $p$ termine au round $r$, et est le premier. Nécessairement, $\xi \in HO(p,r)$.
	La ligne 12 du code montre que la valeur envoyé par $\xi$ est $0$.
	Donc tous les processes ont reçus un $0$. Soit $p$ un processus actif quelquonque. Au round $r$, il execute, dans sa fonction de transition, l'une des quatre branches possibles.
	\begin{itemize}

		\item Si un processes $p$ est dans la première branche, il termine en même temps que $\xi$.
		\item Il ne peut pas exécuter la troisième branche car $M(\xi) = 0$.
		\item S'il exécute la deuxième ou la quatrième branche, il adopte $0$.

	\end{itemize}

	On montre maintenant par récurrence la proposition suivante :

	"Pour tout $i \in \mathds{N}$, la valeur de $p$ au round $r+i$ est $i~mod~k$ si $p$ est actif et n'a pas djéà terminé à ce round."

	\textbf{Initialisation : } voir ci-dessus

	\textbf{Hérédité :}

	On suppose que $\forall p \in \mathcal{A}_{r+i}, x_p(r+i) = i~mod~k$, on veut montrer que $\forall p \in \mathcal{A}_{r+i+1}, x_p(r+i+1) = i+1~mod~k$.
	L'hypothèse de récurrence montre qu'au round $r+i+1$, la seule valeur envoyée sera $i~mod~k$.
	Si un processus termine au round $r+i+1$, on a, d'après les lignes 7 et 17, $i~mod~k = 0$, la sûreté est vérifiée.
	Sinon, la ligne $14$ s'exécute, cela achève la récurrence.

	La sûreté découle de cette proposition.

\end{proof}

On montre maintenant la terminaison dans un cas simple.
Soit $\mathcal{P}_{star} \equiv \exists \xi \in \Pi, \forall p \in \Pi, \forall r \in \mathds{N}, HO(p, r) = \{\xi\}$

\begin{lemma}
	Étant donnée une exécution de cet algorithme. On suppose que le graphe dynamique vérifie $\mathcal{P}_{nek-fixed}$.
	On suppose également que $\xi$ termine au round $r$.
	Alors tous les processus non indéfiniment passifs terminent également, lors des rounds ultérieurs à $r$.
\end{lemma}
\begin{proof}
	Si $\xi$ termine au round $r$, $\xi$ s'envoie nécessairement la valeur $0$ à lui-même. Donc $\xi$ envoie $0$ à tous les processus. 
	Donc tous les processes adoptent $0$.
	On suit un raisonnement similaire à celui de la preuve de la sûreté.
	on montre trivialement par récurrence qu'au round $r+i$, tous les processes ont $i~mod~k$ comme valeur de compteur.
	Donc lors des rounds $r+k+i$ vérifiant $i~mod~k = 0$, tous les processus qui n'ont pas déjà terminés terminent.
	Cela prouve la terminaison.
\end{proof}
\begin{theorem}
	Toute exécution de cet algorithme termine vis-à-vis du problème de synchronisation modulo k lorsque les prédicats $\mathcal{P}_{star}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	Soit $r$ le round auquel $\xi$ s'active.
	On montre trivialement par récurrence que la valeur du compteur de $\xi$ au round $r+i$ est $i~mod~k$.
	Ainsi, $\xi$ recevra seulement au round $r+k$ sa propre valeur, à savoir $0$. Donc $\xi$ terminera au round $r+k$. Le lemme précédent achève donc la terminaison.
\end{proof}

On montre maintenant la terminaison dans le cas qui nous intéresse.

\begin{theorem}
	Toute exécution de cet algorithme termine vis-à-vis du problème de synchronisation modulo k lorsque les prédicats $\mathcal{P}_{nek-fixed}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	Soit $r$ le round auquel $\xi$ s'active.

\end{document}
