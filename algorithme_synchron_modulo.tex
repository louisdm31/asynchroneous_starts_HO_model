\documentclass{article}
\usepackage{amsmath}
\usepackage[noend]{sources_Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{definition}{Définition}
\setlength{\parskip}{0.22cm}
%\newcommand{\st0}{q^0}


\title{Algorithme de synchronisation modulo k}
\date{10 juillet 2020}
\author{Louis Penet de Monterno}

\begin{document}

\maketitle

\section{Problème}

Il est courant de rencontrer des algorithmes de consensus, structurés par phases : 
à chaque rounds pairs, les processus exécutent une certaine fonction de transition. Et au round impairs, une autre fonction de transition est exécutée.
Lorsque les départs sont synchrones, tous les processus exécutent la même fonction de transition à chaque round.
Lorsqu'il y a des départs asynchrones, les phases paires des différents processus ne sont plus simultanées, et cela peut compromettre la sûreté de l'algorithme.
Le but de ce document est de proposer un algorithme permettant de synchroniser les différentes phases malgré les départs asynchrones.

\begin{definition}

	Soit un paramètre $k > 1$. Soit $s_{exit} \in States_p$ un état final.
	Étant donnée une exécution d'un algorithme $A$, pour tout $p \in \Pi$, on note $t_p$ le round auquel $p$ atteint $s_{exit}$ ($t_p = \infty$ sinon).
	Cette exécution de l'algorithme $A$ est sûr vis à vis du problème de synchronisation modulo $k$ si,
	$$\exists c \in \mathds{N}, \forall p \in \bigcup\limits_{i \in \mathds{N}} \mathcal{A}_i, t_p \neq \infty \Rightarrow t_p~mod~k = c$$

\end{definition}

\begin{definition}

	Une exécution de l'algorithme $A$ vérifie la terminaison vis à vis du problème de synchronisation modulo $k$ si,
	$$\forall p \in \bigcup\limits_{i \in \mathds{N}} \mathcal{A}_i, t_p \neq \infty$$

\end{definition}
\begin{definition}
	L'algorithme $A$ résoud le problème de synchronisation modulo $k$, si toute exécution de $A$ est sûre et termine.
\end{definition}

Pour la suite, on considère une valeur $k > 2$ quelquonque.

\section{Algorithme}

L'objectif est de résoudre ce problème dans les conditions suivantes :
\begin{itemize}

	\item Le graphe dynamique contient une étoile fixe : $\mathcal{P}_{nek-fixed} \equiv \exists \xi \in \Pi, \forall p \in \Pi, \forall r \in \mathds{N}, \xi \in HO(p, r)$
	\item Tous les processus s'activent en temps fini : $\mathcal{P}_{non-inf} \equiv \exists r \in \mathds{N}, \mathcal{A}_r = \Pi$

\end{itemize}

L'idée de l'algorithme ci-dessous est que chaque processus possède un compteur modulo $k$. À chaque round, il incrémente son compteur, et l'envoie à tous.
Il reçoit alors les valeurs de compteur de tous ses voisins entrants. Il essaye de se synchroniser avec les autres processus s'ils s'accordent tous sur une même valeur de compteur
(deuxième branche dans la fonction de transition).

Sinon, il fait une tentative de "synchronisation forcée", c'est-à-dire il essaye de convaincre tous les processus de se synchroniser sur son propre compteur :
il adopte la valeur $k-1$ (troisième branche). Au prochain round, il envoie 0.  Les processus qui reçoivent ce 0 sont obligés de l'adopter (quatrième branche).
Chaque processus ne fait qu'une seule fois cette tentative de synchronisation forcée (la variable $try_p$ sert justement à limiter $p$ à une seule tentative).

\pagebreak[1]

\begin{algorithm}[htb]
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
  \STATE $x_p :=\, 0$ 
  \STATE $try_p = true$

\ENDINDENT \BLANK

\INDENT{\textbf{Round 0:}}
 \INDENT{$S_p:$}
    \STATE send $nil$ to all processes
  \ENDINDENT
\ENDINDENT
  \BLANK
\INDENT{\textbf{Round $r+1$:}}
 \INDENT{$S_p:$}
    \STATE send $x_p+1~mod~n$ to all processes
  \ENDINDENT
\ENDINDENT
  \BLANK
\INDENT{\textbf{Round $r$:}}
	\INDENT{$T_p(M):$}
	\IF{$M(\Pi) = \{0\}$}
	\STATE $EXIT()$ ~~~~\COMMENT{si tous les messages reçus valent 0, aucun $nil$, l'algorithme termine}
	\ELSIF{$M(\Pi) \setminus \{nil\} = \{v\}$}
	\STATE $x_p = v$ ~~~~\COMMENT{si tous les messages ont la même valeur, s'aligner}
	\ELSIF{$try_p \wedge 0 \notin M(\Pi)$}
	\STATE $try_p = false$ ~~~~\COMMENT{si plusieurs messages sont discordants, faire une tentative de synchronisation forcée}
	\STATE $x_p = k - 1$
	\ELSE
	\STATE $x_p = 0$ ~~~~\COMMENT{si un 0 a été reçu, toujours s'aligner}
	\ENDIF
  \ENDINDENT
\ENDINDENT 
\caption{The {\em SyncMod} algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

\begin{lemma}
	Toute exécution de cet algorithme est sûr vis-à-vis du problème de synchronisation modulo k lorsque les prédicats $\mathcal{P}_{nek-fixed}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{lemma}
\begin{proof}

	Soit $\xi$ le processes au centre de l'étoile.
	On suppose que $p$ termine au round $r$, et est le premier. Nécessairement, $\xi \in HO(p,r)$.
	La ligne 12 du code montre que la valeur envoyé par $\xi$ est 0.
	Donc tous les processes ont reçus un 0. Soit $p$ un processus actif quelquonque. Au round $r$, il execute, dans sa fonction de transition, l'une des quatre branches possibles.
	\begin{itemize}

		\item Si un processes $p$ est dans la première branche, il termine en même temps que $\xi$.
		\item Il ne peut pas exécuter la troisième branche car $M(\xi) = 0$.
		\item S'il exécute la deuxième ou la quatrième branche, il adopte 0.

	\end{itemize}

	On montre maintenant par récurrence sur $i$ la proposition suivante :

	"Pour tout $i \in \mathds{N}$, la valeur de $p$ au round $r+i$ est $i~mod~k$ si $p$ est actif et n'a pas déjà terminé à ce round."

	\textbf{Initialisation : } voir ci-dessus

	\textbf{Hérédité :}

	On suppose que $\forall p \in \mathcal{A}_{r+i}, x_p(r+i) = i~mod~k$, on veut montrer que $\forall p \in \mathcal{A}_{r+i+1}, x_p(r+i+1) = i+1~mod~k$.
	L'hypothèse de récurrence montre qu'au round $r+i+1$, la seule valeur envoyée sera $i~mod~k$.
	Si un processus termine au round $r+i+1$, on a, d'après la ligne 12, $i~mod~k = 0$, donc la sûreté est vérifiée.
	Sinon, la ligne $14$ s'exécute, cela achève la récurrence.

	La sûreté découle de cette proposition.

\end{proof}

Pour les trois lemmes ci-dessous, on se fixe une exécution de l'algorithme.
On dit que le système est synchonisé au round $i$ si tous les processus actifs ont la même valeur de compteur.

\begin{lemma}
	Sous le prédicat $\mathcal{P}_{nek-fixed}$,
	si au round $i$, $\xi$ est actif et le système est synchonisé, il l'est également au round $i+1$.
\end{lemma}
\begin{proof}
	Si le système est synchronisé au round $i$, au round $i+1$, tous les processus enverront une même valeur $v$.
	Donc, pour tout $p \in \mathcal{A}_{i+1}$, on aura $M_p^{i+1}(\Pi) \subseteq \{v+1~mod~k, nil\}$.
	Le fait que $\xi$ est actif induit $v+1~mod~k \in M_p^{i+1}(\Pi)$.
	Donc la deuxième branche de la fonction de transition sera exécutée.
	La synchronisation est donc maintenue.
\end{proof}
\begin{lemma}
	Sous les prédicats $\mathcal{P}_{nek-fixed}$ et $\mathcal{P}_{non-inf}$,
	si au round $i$, $\xi$ est actif et le système est synchonisé, tous les processus terminent.
\end{lemma}
\begin{proof}
	Le lemme précédent montre qu'à partir du round $i$, le système reste synchonisé. De plus, à chaque round, la valeur des compteurs est incrémentée.
	Soit $r$ le round à partir duquel tous les processus sont actifs.
	Ainsi, lors d'un round $i' \geq max(i, r)$, le système atteindra un état dans lequel tous les compteurs valent $k-1$.
	On aura alors, au round suivant, $\forall p \in \Pi, M_p^{i'}(\Pi) = \{0\}$.
	Donc tous les processus terminent.
\end{proof}

On montre maintenant la terminaison dans un cas simple.
Soit $\mathcal{P}_{star} \equiv \exists \xi \in \Pi, \forall p \in \Pi, \forall r \in \mathds{N}, HO(p, r) = \{\xi\}$

\begin{theorem}
	L'algorithme résout la synchronisation modulo $k$ lorsque les prédicats $\mathcal{P}_{star}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	Soit $r$ le round auquel $\xi$ s'active.
	On montre trivialement par récurrence sur $i$ que la valeur du compteur de $\xi$ au round $r+i$ est $i~mod~k$.
	Ainsi, au round $r+k$, $\xi$ enverra 0 à tous, donc le système se synchronisera sur 0.
	Le lemme précédent montre la terminaison, et le lemme 1 la sûreté.
\end{proof}

On montre maintenant la terminaison dans le cas qui nous intéresse.

\begin{theorem}
	L'algorithme résout la synchronisation modulo $k$ lorsque les prédicats $\mathcal{P}_{nek-fixed}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	Soit $r$ le round auquel $\xi$ s'active.
	L'algorithme est conçu de telle manière que chaque processus n'exécute la troisième branche de la fonction de transition qu'une seule fois.
	Donc il existe un round $r' \geq r$ à partir duquel plus aucun processus n'exécute cette troisième branche.

	\begin{description}

		\item[Cas 1 : ] $\xi$ a exécuté la troisième branche de la fonction de transition au cours d'un round $t \geq r$.

			Dans ce cas, au round $t+1$, $\xi$ envoie 0 à tous, donc tous les processus s'alignent sur ce 0. Le système est maintenant synchonisé. Le lemme précédent montre la terminaison.

		\item[Cas 2 : ] $\xi$ n'a jamais exécuté la troisième branche, et n'a pas exécuté la quatrième branche au delà du round $r'$.

			Dans ce cas, au delà du round $r'$, $\xi$ n'exécute que les deux premières branches. Un raisonnement similaire à la preuve du théorème 1 montre la terminaison.

		\item[Cas 3 : ] $\xi$ n'a jamais exécuté la troisième branche, mais a exécuté la quatrième branche au round $t \geq r'$.

			Ainsi, au round $t+1$, $\xi$ envoie 1 à tous. Comme $t \geq r'$, les processus ne peuvent exécuter que la deuxième et la quatrième branche.
			Les seules valeurs présentes dans le système à la fin du round $t+1$ sont donc 0 et 1.
			On distingue deux sous-cas possibles :

			\begin{description}

				\item[Sous-cas 3.1] $x_\xi(t+1) = 1$

					Dans ce cas, on montre par récurrence sur $i$ que
					$$\forall i \in \mathds{N}, x_\xi(t+i) = i~mod~k \wedge \forall p \in \mathcal{A}_{t+i}, x_p(t+i) \leq x_\xi(t+i)$$

					\textbf{Initialisation : } voir ci-dessus.

					\textbf{Hérédité : } Pour $i$ donné, on suppose que 
					$$x_\xi(t+i) = i~mod~k \wedge \forall p \in \mathcal{A}_{t+i}, x_p(t+i) \leq x_\xi(t+i)$$
					L'hypothèse de récurrence montre que les messages envoyés au round $t+i+1$ sont compris entre 1 et $i+1~mod~k$.
					Le processus $\xi$ reçoit toujours sa propre valeur, à savoir $i+1~mod~k$, mais n'en reçoit jamais d'autre, celà provoquerait l'exécution de la troisième branche.
					On a pourtant supposé que $\xi$ n'exécutait jamais cette branche. Cela prouve $x_\xi(t+i+1) = i+1~mod~k$.

					Les autres processus reçoivent au round $t+i+1$ des valeurs comprises entre 1 et $i+1~mod~k$, cela prouve $\forall p \in \mathcal{A}_{t+i}, x_p(t+i) \leq x_\xi(t+i)$.

					Cette récurrence montre qu'au round $t+k$, $\xi$ envoie 0 à tous, ce qui synchrones le système. Le lemme précédent assure la terminaison.

				\item[Sous-cas 3.2] $x_\xi(t+1) = 0$

					Dans ce cas, $\xi$ envoie 1 à tous les processus au round $t+i+1$. Les valeurs envoyées par les autres processus sont nécessairement 1 et 2.
					$\xi$ ne peut pas avoir reçu un 2, car on a supposé que $\xi$ n'a jamais exécuté la troisième branche. Donc la valeur de $\xi$ à la fin du round est nécessairement 1.
					Pour les autres processus, les seules valeurs possibles sont 0 et 1. On est donc ramené au cas précédent.
			\end{description}
	\end{description}

	Cette disjonction de cas achève donc la terminaison. La sûreté étant garantie par le lemme 1.
\end{proof}

\end{document}
