\documentclass{article}
\usepackage{amsmath}
\usepackage[noend]{sources_Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{definition}{Définition}
\setlength{\parskip}{0.22cm}
%\newcommand{\st0}{q^0}


\title{Résolubilité du consensus sous différents prédicats}
\date{17 juin 2020}
\author{Louis Penet de Monterno}
\begin{document}
\maketitle

\section{Théorèmes d'impossibilité}

Soit $\xi \in \Pi$ un pocessus fixé.
On pose $\Phi$ le prédicat $\forall t \in \mathds{N}, \forall q \in \Pi, path(\mathds{G}(t : t+k), \xi, q)$, où $path(G, \xi, q)$ signifie qu'il existe un chemin de $\xi$ vers $q$ dans le graphe $G$.

\begin{theorem}
	Le consensus n'est pas fortement résoluble sous l'hypothèse $P_k(\Phi)$ où $k$ est un entier quelquonque.
\end{theorem}
\begin{proof}
	Si la racine est passive pour toujours, le prédicat n'est pas exploitable.
\end{proof}

On pose $\Psi$ le prédicat $\forall t \in \mathds{N}, \exists p \in \Pi, \forall q \in \Pi, path(\mathds{G}(t : t+k), p, q)$.
\begin{theorem}
	Le consensus n'est pas résoluble sous l'hypothèse $P_k(\Psi)$ où $k$ est un entier quelquonque.
\end{theorem}
\begin{proof}
	On suppose qu'un algorithme $A$ résoud le consensus sous le prédicat $P_k(\Psi)$. Soient $p_1, p_2 \in \Pi$.
	\begin{itemize}

		\item \textbf{Scénario 1 :} $\mathds{G}_n$ est pour tout $n$ égal à l'étoile centrée en $p_1$. On exécute l'algorithme $A$. La terminaison assure que $p_1$ décidera en un round $r$.
		\item \textbf{Scénario 2 :} Pour tout $n \leq r$, $\mathds{G}_n$ est l'étoile centrée en $p_1$. Pour tout $n > r$, $\mathds{G}_n$ est l'étoile centrée en $p_2$. On suppose que $p_2$
			s'active au round $r+1$. Dans ces conditions, $p_2$ ne reçoit jamais de message. La terminaison et l'intégrité assurent que $p_2$ décide finalement sa valeur initiale,
			tandis que $p_1$ a déjà décidé. Dans ces conditions, l'accord est impossible à assurer.

	\end{itemize}
\end{proof}

\section{Algorithme "Uniforme Voting"}

Dans cette section, on propose une adaptation de l'algorithme  "Uniforme Voting", prévue pour fonctionner avec des départs asynchrones.
Soit $V$ un ensemble totalement ordonné.

\begin{itemize}

	\item Pour tout processus $p$, on pose
		$State_p = V \times Bool \times Bool \times V \times Bool \times Bool \times Bool$.
	\item Pour tout processus $p$, on pose
		$Init_p = \{\langle v, False, False, v, False, False, False \rangle, v \in V\}$
	\item Les messages sont de type $V \times (V \times Bool \uplus \{nil\})$.


	\item On définit $fst : V \times (V \times Bool \uplus \{nil\}) \uplus \{nil\} \rightarrow V \uplus \{nil\}$ par
	\begin{itemize}
		\item $fst(nil) = nil$
		\item $fst(\langle v, w \rangle) = v$
	\end{itemize}

	\item On définit $snd : V \times (Bool \times Bool \uplus \{nil\}) \uplus \{nil\} \rightarrow (V \times Bool) \uplus \{nil\}$ par
	\begin{itemize}
		\item $fst(nil) = nil$
		\item $fst(\langle v, w \rangle) = w$
	\end{itemize}
\end{itemize}

On définit l'algorithme "Uniforme Voting" à l'aide du pseudo-code suivant :
\begin{algorithm}[htb]
\scriptsize{
\begin{distribalgo}[1]
\begin{tabular}{ll}
\begin{minipage}{41em}


\INDENT{\textbf{Initialization:}}
	\STATE $x^1_p :=\, v_p$ ~~~~\{\emph{$v_p$ is the initial value of $p$}\}
	\STATE $vote^1_p \in Bool$, initiallement $False$
	\STATE $dec^1_p \in Bool$, initialement $False$
	\BLANK
	\STATE $x^2_p :=\, v_p$
	\STATE $vote^2_p \in Bool$, initiallement $False$
	\STATE $dec^2_p \in Bool$, initialement $False$

\ENDINDENT
\BLANK

\INDENT{\textbf{Fonctions sur une instance}}
	\INDENT{$T^1_p(M, ref ~ x, ref ~ vote, ref ~ dec):$}
		\STATE $ x := min M(\Pi) \setminus \{nil\}$ 
		\IF{$M(\Pi) = \{v\}$} 
			\STATE $vote := True$ ~~~~\{tous les messages valent $v$, aucun $nil$\}
		\ENDIF
	\ENDINDENT
	\BLANK

	\INDENT{$T^2_p(M, ref ~ x, ref ~ vote, ref ~ dec):$}

		\IF{$\exists v \in V, q \in \Pi, M(q) = \langle v, True \rangle$}
			\STATE $x := v$ ~~~~\{au moins un vote reçu\}
		\ELSE
			\STATE $x := fst (min (M(\Pi) \setminus {nil}))$ ~~~~\{plus petite valeur reçue\}
		\ENDIF
		\IF{$M(\Pi) = \{\langle v, True \rangle\}$}
			\STATE $dec := True$ ~~~~\{tous les messages sont des votes pour $v$\}
		\ENDIF
		\STATE $vote_p := False$
	\ENDINDENT
\ENDINDENT

\end{minipage}
&
\begin{minipage}{31em}

\INDENT{\textbf{Round $r=0\,$:}}
	\INDENT{$S_p:$}
		\STATE send $\langle nil, \langle  x^1_p , False \rangle \rangle$ to all processes
	\ENDINDENT
	\INDENT{$T_p(M):$}
		\STATE $T^2(snd \circ M, x^1_p, vote^1_p, dec^1_p)$
	\ENDINDENT
\ENDINDENT

\INDENT{\textbf{Round $r=2\phi+1\,$:}}
	\INDENT{$S_p:$}
		\STATE send $\langle\, x^1_p\, ,\, \langle \, x^2_p \, ,\, vote^2_p \, \rangle \, \rangle$ to all processes
	\ENDINDENT
	\BLANK
	\INDENT{$T_p(M):$}
		\STATE $T^1(fst \circ M, x^1_p, vote^1_p, dec^1_p)$
		\STATE $T^2(snd \circ M, x^2_p, vote^2_p, dec^2_p)$
		\IF{$dec^1_p \wedge dec^2_p $}
			\STATE $DECIDE(min ~ x^1_p ~ x^2_p)$
		\ENDIF
	\ENDINDENT
\ENDINDENT

\INDENT{\textbf{Round $r=2\phi+2\,$:}}
	\INDENT{$S_p:$}
		\STATE send $\langle x^2_p , \langle x^1_p, vote^1_p \rangle \rangle$ to all processes
	\ENDINDENT
	\BLANK
	\INDENT{$T_p(M)$}
		\STATE $T^1_p(fst \circ M, x_p^2, vote^2_p, dec^2_p)$
		\STATE $T^2_p(snd \circ M, x_p^1, vote^1_p, dec^1_p)$
		\IF{$dec^1_p \wedge dec^2_p $}
			\STATE $DECIDE(min ~ x^1_p ~ x^2_p)$
		\ENDIF
	\ENDINDENT
\ENDINDENT

\end{minipage}
\end{tabular}

\caption{The {\em UniformVoting} algorithm}
\label{unifvotfig}
\end{distribalgo}
}
\end{algorithm}

\textbf{Observations :} Cet algorithme consiste en fait à exécuter deux instances de "Uniforme Voting" en parallèle.
L'état est donc la concaténation de deux sous-états.
Les deux fonctions $T^1$ et $T^2$ définissent le comportement de chaque instance induviduellement.
Au round $0$, seule la première instance démarre.
Aux rounds impairs, la première instance effectue sa phase d'échange de vote, tandis que la seconde, sa phase d'échange de valeurs.
Aux rounds pairs, c'est l'inverse.
À chaque round, les processus reçoivent des messages de la forme $\langle x_1 , \langle x_2, vote_2 \rangle \rangle$.
Si $M$ est la fonction de réception, pour un round donné, et un processus fixé, $fst \circ M$ est la fonction de réception restreinte à l'échange de valeurs.
De même $snd \circ M$ est celle restreinte à l'échange de vote.
On constate que, à chaque round, les instances qui en sont à la phase d'échange de valeur communiquent exclusivement entre elles, et de même pour celles qui en sont à l'échange de vote.
On note donc $\mathcal{U}_{vote}^n$, qui à chaque processus $p$ associe l'objet $\langle x^i_p, vote^i_p, dec^i_p \rangle$
correspondant à l'instance qui en est à l'échange de vote au round $n$, ou $nil$ si inactif. On note de même $\mathcal{U}_{val}^n$.

\subsection{Intégrité}
\begin{lemma}
	$\forall n \in \mathds{N}, \forall p \in \mathcal{A}_{n+1},  x^1_p(n) \in \{\sigma^0_q, q \in \Pi\}$ (resp. $x^2_p(n) \in \{\sigma^0_q, q \in \Pi\}$).
\end{lemma}
\begin{proof}

	On montre ce lemma par récurrence sur $n$.

	\textbf{Initialization :} Triviale, car $p \in \mathcal{A}_1 \Rightarrow x^1_p(0) = \sigma^0(p)$.

	\textbf{Hérédité :} On suppose, pour un $n$ fixé, que $\forall p \in \mathcal{A}_{n+1},  x^1_p(n) \in \{\sigma^0_q, q \in \Pi\}$.
	Soit $p \in \mathcal{A}_{n+2}$. Soit $r$ le round auquel $p$ s'est activé. Du point de vue du procesus $p$, le numéro du round $n$ est en fait $n-r$.
	\begin{itemize}

		\item Si $n-r$ est impair, et si $p$ a reçu un vote $\langle v, True \rangle$, on a $x^1_p(n+1) = v$ (cf. ligne 14-15 dans le pseudo-code).
			On applique l'hypothèse de récurrence au procesus qui a émis ce vote.
			Ainsi, il existe un procesus $q$ tel que  $x^1_p(n+1) = x^1_q(n) \in \{\sigma^0_q, q \in \Pi\}$.
		\item Sinon, $x^1_p(n+1) = min (M(\Pi) \setminus \{nil\})$ (cf. lignes 10 et 17 dans le pseudo-code).
			On considère le procesus $q$ tel que $min (M(\Pi) \setminus \{nil\}) = M(q)$,
			et on applique à $q$ l'hypothèse de récurrence. Ainsi $x^1_p(n+1) = x^1_q(n) \in \{\sigma^0_q, q \in \Pi\}$.

	\end{itemize}
\end{proof}

\begin{lemma}
	Toute exécution de l'algorithme "Uniforme Voting" vérifie l'intégrité.
\end{lemma}
\begin{proof}
	En utilisant les deux versions de ce lemme, on montre que $\forall n \in \mathds{N}, \forall p \in \mathcal{A}_n, min (x^1_p(n), x^2_p(n)) \in \{\sigma^0_q, q \in \Pi\}$.
	Cela prouve l'intégrité.
\end{proof}

\subsection{Accord}

\begin{lemma}
	Toute exécution de l'algorithme "Uniforme Voting" vérifie l'accord lorsque le graphe dynamique vérifie le prédicat $\exists \xi \in \Pi, \forall n \in \mathds{N}, \xi \in K(n)$.
\end{lemma}
\begin{proof}
	Supposons que la première instance de $p$ décide au round $n$ une valeur $v$, et que cette instance soit la première à décider parmi les autres instances synchrones.
	On sait que $\xi \in \mathcal{A}_n$, sinon tous les processus recevrait au moins un message $nil$ à chaque rounds, cela empêcherait tout vote, dou=nc toute décision.
	On montre par récurrence sur $k$ que $\forall k \in \mathds{N}, \forall q \in \mathcal{A}_{n+k}, x^1_q(n+2k) = v \wedge x^1_q(n+2k+1) = v \wedge vote^1_q(n+2k+1) = True$.

	\textbf{Initialization :} La ligne 18 du pseudo-code montre que $snd \circ M^n_p(\xi) = \{\langle v, True \rangle\}$.
		Ainsi, au round $n$, $\xi$ a envoyé à tous les processus un message de la forme $\langle *, \langle v, True \rangle \rangle$.
		La ligne 15 du pseudo-code montre que, pour tout $q \in \mathcal{A}_n$, $M_p^n(\xi)$ est de la forme $\langle *, \langle v, True \rangle \rangle$.
		Donc $\forall q \in \Pi, x^1_q(n) = v$.

		On ajoute maintenant la preuve que $\forall q \in \Pi, x^1_q(n+1) = v \wedge vote^1_q(n+1) = True$.
		La ligne 10 du pseudo-code montre que $x^1_q(n+1) = min(M(\Pi) \setminus \{nil\}$ avec $M = fst \circ M_q^{n+1}$.
		De plus les instances s'activent toujours lors des phrases d'échanges de votes. Donc $M^{-1}(V) = \mathcal{A}_{n}$.
		Sachant que $\forall q \in \mathcal{A}_n, x^1_q(n) = v$, on obtient $M(\Pi) \setminus \{nil\} = \{v\}$. Donc $x^1_q(n+1) = v \wedge vote^1_q(n+1) = True$.
		Cela clos l'initialisation.

	\textbf{Hérédité :} Pour $k$ fixé, on suppose que $\forall q \in \mathcal{A}_{n+k}, x^1_q(n+2k) = v \wedge x^1_q(n+2k+1) = v \wedge vote^1_q(n+2k+1) = True$.
		Soit $q \in \mathcal{A}_{n+k+2}$.
		Lors du round $n+k+2$, tous les processus reçoivent de la part de $\xi$, un message de la forme $\langle *, \langle v, True \rangle \rangle$
		Donc $\forall q \in \Pi, x^1_q(n+2k+2) = v$.
		De la même manière que pour l'initialisation, on en déduit que $\forall q \in \Pi, x^1_q(n+2k+3) = v \wedge vote^1_q(n+2k+3) = True$.
		Cela clos l'hérédité.
	\begin{itemize}

	À partir de cette proposition, on montre que toute décision ultérieure au round $n$ décidra nécessairement $v$. Cela prouve l'accord de chacune des instances de l'algorithme,
	donc cela prouve l'accord de l'algorithme dans son ensemble.
\end{proof}

\subsection{Terminaison}

	\begin{lemma}
		Soit $r$ le round auquel $\xi$ s'active.
		Pour toute exécution vérifiant $\forall n \in \mathds{N}, \xi \in K(n)$,
		la suite $(x^1_\xi(n+r))_{n \in \mathds{N}}$ (resp. $(x^2_\xi(n+r))_{n \in \mathds{N}}$) est décroissante.
	\end{lemma}
	\begin{proof}
		Soit $n \in \mathds{N}$.
		\begin{itemize}

			\item Si $n+1$ est pair, la ligne 10 du pseudo-code assure que $x^1_\xi(n+r+1) = min(M(\Pi) \setminus \{nil\})$ avec $M = fst \circ M_\xi^{n+r+1}$.
				Or $M_\xi^{n+1}(\xi) = \langle x^1_\xi(n), * \rangle$.
				Donc $x^1_\xi(n+1) \leq x^1_\xi(n)$.
			\item Si $n+1$ est impair et si $\exists v \in V, \exists q \in \mathcal{A}_{n+r+1}, M(q) = \langle v, True \rangle$ avec $M = snd \circ M_\xi^{n+r+1}$,
				on a nécessairement $v = x^1_\xi(n+r)$, puisque $\xi$ a envoyé $x^1_\xi(n+r)$ au round $n+r$ (cf. lignes 11-12).
				Donc $x^1_\xi(n+r+1) = x^1_\xi(n+r)$.
			\item Sinon la ligne 17 du pseudo-code assure que $x^1_\xi(n+r+1) = min(fst \circ M(\Pi) \setminus \{nil\})$ avec $M = snd \circ M_\xi^{n+r+1}$.
				Or $M_\xi^{n+r+1}(\xi) = \langle x^1_\xi(n+r), * \rangle$.
				Donc $x^1_\xi(n+r+1) \leq x^1_\xi(n+r)$.

		\end{itemize}
		Dans tous les cas, $x^1_\xi(n+r+1) \leq x^1_\xi(n+r)$.
	\end{proof}
		

	\begin{lemma}
		Toute exécution de "Uniforme Voting" vérifie la terminaison lorsque le graphe de communication vérifie $\forall n \in \mathds{N}, \xi \in K(n)$.
	\end{lemma}
	\begin{proof}
		On montre l'accord pour chacune des deux instances de l'algorithme.
		En combinant le lemme 1 et le lemme précédent, on montre que la suite $(x^1_\xi(n+r))_{n \in \mathds{N}}$ se stabilise sur une valeur $v$ à partir d'un certain round $n+r$.
		Au round $2n+r+1$, le processus $\xi$ envoie donc un message de la forme $\langle v, * \rangle$ à tous les processus.
		La ligne 10 du pseudo-code assure que
		On a donc $x^1_\xi(r+2n)$
		Supposons que, pour $n \in \mathds{N}$ et $p \in \mathcal{A}_n$ fixée, la première instance décide une valeur $v$.
		La ligne 18 du pseudo-code assure que $snd \circ M_p^n(\Pi) = \{\langle v, True \rangle\}$.
		Ainsi $\xi$ envoie $\{\langle v, True \rangle\}$ au round $n$.





	\end{proof}


\begin{theorem}
	L'algorithme "Uniforme Voting" ainsi adapté résoud le consensus sous l'hypothèse $P_k(\Phi)$ lorsque les processu connaissent $k$.
\end{theorem}
\begin{proof}
	On montre trivialement qu'il existe un algorithme A qui traduit $P_k(\Phi)$ en $\mathcal{P}_{nek}$. On montre maintenant que "Uniforme Voting" résoud le consensus sous $\mathcal{P}_{nek}$.

	À partir du prédicat $\exists n, \mathcal{A}_n = \Pi$, on obtient un round n tel que tous les processus sont actif.

	\textbf{Intégrité :}

	L'intégrité et l'accord résultent du fait que $\mathcal{P}_{nek} \Rightarrow \mathcal{P}_{nosplit}$. On prouve maintenant la terminaison.
\end{proof}

\begin{theorem}

	L'algorithme "Uniform Voting" résoud faiblement le consensus 

	\begin{itemize}

	\item Le graphe dynamique vérifie $\mathcal{P}_{nek}$.
	\item L'ensemble des valeurs $\mathcal{V}$ est bien-fondé.
	\item Les processus connaissent une borne supérieur $\mathcal{N}$ sur la taille du système.

	\end{itemize}
\end{theorem}

\begin{proof}

	On considère une exécution de "Uniforme Voting". Cette exécution définie donc
	une fonction $x : \Pi \rightarrow \mathds{N} \rightarrow \mathcal{V}$ et une fonction $vote$ de même type.
	Une fois la traduction faite, on peut obtenir une suite $(p_n)_{n \in \mathds{N}}$ où $\forall n \in \mathds{N}, p_n \in K(n)$.

	\textbf{Assertion :} $\forall n \in \mathds{N}, \forall q \in \Pi, x(q,n+1) \leq x(p_{n+1},n)$.
	\begin{itemize}

	\item cas 1 : $n = 2 \Phi$. Dans ce cas, $q$ a reçu $x(p_n,n)$ 

	\end{itemize}

	On montre maintenant que la suite $(x(p_n, n))_{n \in \mathds{N}}$ est décroissante.
\end{proof}
\end{document}
