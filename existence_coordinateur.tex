
\documentclass{article}
\usepackage{amsmath}
\usepackage{algpseudocode}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{graphicx}
\usepackage[left=2cm, right=2cm, top=1.9cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Théorème}

\title{Établissement d'une condition nécessaire pour la résolubilité du consensus avec départs asynchrones}
\date{12 mai 2020}
\author{Louis Penet de Monterno}

\begin{document}
\maketitle

\begin{lemma}

Si une machine $(A, \mathcal{P})$ résout le consensus avec départs asynchrones, on a
$\mathcal{P} \Rightarrow \mathcal{P}_{coord}$ où $\mathcal{P}_{coord} = \exists p \in \Pi,
\forall q \in \Pi, \forall n \in \mathds{N}, \exists k \in \mathds{N},
\exists (p_0 = p, p_1, ... p_k = q), \exists (r_0, r_1, ... r_k), r_0 \geq n
\wedge \forall i \in \{1, ..., k\}, p_i \in HO(r_i, p_{i-1}) \wedge r_i > r_{i-1}$

On introduit la notation $path(p, q, n)$ où
	$\mathcal{P}_{coord} = \exists p \in \Pi, \forall q \in \Pi, \forall n \in \mathds{N}, path(p, q, n)$ 

Intuitivement, il existe un coordianteur, dont les messages peuvent toujours parvenir à tous les processus.
Pour tout n, il existe un k suffisamment grand tel que ce coordianteur enracine le graphe $\mathds{G}(n:n+k)$.

\end{lemma}
\begin{proof}

	Pour tout couple de processus $(p, q)$, le prédicat $\forall n \in \mathds{N}, path(p, q, n)$ est vrai si et seulement si il existe infiniment souvent un chemin de $p$ à $q$.
	Cela permet de définir le graphe $H = (\Pi, E)$ ou $E$ contient l'arête $(p,q)$ si et seulement si $\forall n \in \mathds{N}, path(p, q, n)$.
	À partir de $H$, on construit $H_{meta} = (V_{meta}, E_{meta})$ ou $V_{meta}$ est l'ensemble des composantes connexes de H, et $E_{meta}$ contient l'arête $(p_{meta}, q_{meta})$
	si et seulement si l'un des processus de la composante $p_{meta}$ peut communiquer infiniment souvent avec un des processus de la composante $q_{meta}$.
	(ie. si $\forall n \in \mathds{N}, \exists p \in p_{meta}, q \in q_{meta}, path(p,q,n)$)

	\begin{figure}[ht!]
		\centering
		\includegraphics[width=9cm]{coordinateur.jpg}
		\caption{Exemple de graphe}
	\end{figure}

	$H_{meta}$ est acyclique, puisque tout cycle de $H_{meta}$ formerait une seule composante commexe dans $H$, donc un seul sommet dans $H_{meta}$.
	À l'aide d'un tri topologique, on peut donc ordonner les sommets de $H_{meta}$ selon un ordre total qui respecte l'ordre partielle de $H_{meta}$.
	(ie. $\forall p \in V_{meta}, q \in V_{meta}, p \leq q \Leftrightarrow (p,q) \in E_{meta}$)
	On représente cet ordre total par une bijection $f : \{0, ..., n-1\} \rightarrow V_{meta}$ ou $n = |V_{meta}|$.

	\textbf{Proposition :} Pour tout $k > 0$, la composante $f(k)$ dépend d'une composante précédente.

	En effet, supposons par l'absurde que $f(k)$ n'a aucun prédessesseur (ie. à partir d'un certain rang, les processus de $f(k)$ ne reçoivent plus rien de l'extérieur) :
	\begin{itemize}
		\item scénario 1 : tous les processus ont $v_0$ comme valeur initiale.
			On se place dans le cas ou tous les processus de $f(0)$ se réveillent suffisamment tard,
			de tels sorte qu'à leur réveil, toutes les communications venant de l'extérieur de $f(0)$ aient déjà cessées.
			On exécute l'algorithme A. Le consensus assure que tous les processus décident $v_0$.
		\item scénario 2 : tous les processus ont $v_1$ comme valeur initiale.  On se place dans le cas ou tous les processus de $f(k)$ se réveillent suffisamment tard,
			de tels sorte qu'à leur réveil, toutes les communications venant de l'extérieur de $f(k)$ aient déjà cessées. On exécute l'algorithme A. Le consensus assure que tous les processus décident $v_1$.
		\item scénario 3 : les processus de la  composante $f(0)$ ont $v_0$ pour valeur initiale, les autres ont $v_1$.
			\begin{itemize}
				\item On se place dans le cas ou tous les processus de $f(0)$ se réveillent suffisamment tard,
					de tels sorte qu'à leur réveil, toutes les communications venant de l'extérieur de $f(0)$ aient déjà cessées.
				\item On se place dans le cas ou tous les processus de $f(k)$ se réveillent suffisamment tard,
					de tels sorte qu'à leur réveil, toutes les communications venant de l'extérieur de $f(k)$ aient déjà cessées.
			\end{itemize}
			On exécute l'algorithme A.
			Pour les processus de la composante $f(0)$, ce scénario est indistinguable du scénario 1, ils décident donc $v_0$.
			Pour les processus de la composante $f(k)$, ce scénario est indistinguable du scénario 2, ils décident donc $v_1$.
			Cela viole donc l'accord.
	\end{itemize}

	Par une récurrence forte sur k, on montre que pour tout $k$, la composante $f(k)$ dépend de la composante $f(0)$.
	Donc tous les processus de $f(0)$ peuvent infiniment souvent communiquer avec tous les processus du système. Donc tous les processus de $f(0)$ sont des coordinateurs.


\end{proof}
\end{document}
