\documentclass{article}
\usepackage{amsmath}
\usepackage[noend]{sources-Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{stmaryrd}
\usepackage[left=2cm, right=2cm, top=2cm]{geometry}
\usepackage[utf8]{inputenc}
\newtheorem{lemma}{Lemme}
\newtheorem{theorem}{Théorème}
\newtheorem{definition}{Définition}
\setlength{\parskip}{0.22cm}

\usepackage{biblatex}
\addbibresource{rapport.bib}

\title{Vérification et preuve formelle dans le modèle Heard-Of}
\date{2020}
\author{Louis Penet de Monterno - Bernadette Charron-Bost}

\begin{document}

\maketitle

\section{Introduction}

\subsection{Contexte}

On se place dans le contexte d'un réseau de machines, et on souhaite que ce réseau exécute une certaine tâche, margré les pannes pouvant survenir.
Une abondante litérature propose différentes approches permettant de modéliser les systèmes distribués, ainsi que les différents types de pannes possibles.
%L'un des principaux problèmes étudié dans la litérature est le problème du consensus, où les processus doivent s'accorder sur une même valeur parmi un ensemble de valeurs possibles.
Un modèle particulièrement intéressant, connue sous de nom de "modèle Heard-Of" \cite{model_ho},
consiste à envisager les processus comme des machines à états, qui progressent par une succession de rounds "clos par communication".
C'est-à-dire qu'au sein d'un même round, les processus peuvent communiquer.
On localise les pannes au niveau des laisons entre processus. Ainsi, pour un round donné, un processus peut, ou non, envoyer un message à un autre processus.

\subsection{Problème à traiter}

Cet article s'intéresse tout particulièrement au problème du consensus : les processus ont chacun une valeur initiale, et doivent s'accorder sur une valeur parmi l'ensemble des valeurs initiales.
Des travaux antérieurs étudient en profondeur les possibilité offertes par un système modélisé de cette manière, en fonction des hypothèses faites sur la connectivité du réseau.
Mais les travaux existants font une hypothèse qui limite considérablement leur portée, en supposant les départs synchrones : les processus démarrent tous au même moment, au sein d'un même premier round.
L'un des principaux objectifs de cet article est d'étudier la résolubilité du consensus dans un système sans faire l'hypothèses des départs synchrones.
Cet article s'inscrit dans la continuité de \cite{firing_squad}, dont l'objectif était de ramener les systèmes avec départs asynchrones à des systèmes avec départs synchrones, plus simple à traiter.
%Un article a été publié afin de contourner cette limitation  Cet article propose un algorithme distribué, qui peut être démarré de manière asynchrones par les noeuds du réseau,
%mais qui termine au même round pour tous les processus (tous les processus "font feu" en même temps, d'où le nom de l'article).
%À la suite d'un tel algorithme, on peut exécuter un algorithme de consensus par exemple, sans se soucier des problèmes de départs asynchrones.
Mais, avec la méthode proposée, les hypothèses très fortes, faites sur la connectivité du réseau, affectent fortement la tolérance au panne.
Il s'agit donc d'étendre ce résultat avec des hypothèses plus faibles.

\subsection{Contribution proposée}

%Le but de ce travail est d'explorer les possibilités offertes par un systèmes avec départs asynchrones.
%En particulier, on s'intéressera à la résolubilité du consensus avec départs asynchrones, en fonction des hypothèses faites sur la connectivité du réseau.
En cherchant à adapter les principaux algorithmes de consensus connus,
pour les rendre compatibles avec départs asynchrones, un problème intermédiaire, appelé "problème de synchronisation modulo $k$", a été identifié.
En effet, de nombreux algorithmes de consensus, tels que "Uniforme Voting" \cite{model_ho}, reposent sur une alternance de phases, que les processus sont supposés exécuter de façon synchronisée.
Si un algorithme contient $k$ phases, il est nécessaire que les processus démarrent au cours de rounds qui soient congrus modulo $k$.
Cet article propose donc un algorithme qui, en s'inspirant de \cite{firing_squad},
résout le problème de synchronisation modulo $k$, et ouvre donc la voie à la résolubtion du consensus avec départs asynchrones.

\subsection{Preuves proposées}

L'un des avantages du modèle Heard-Of, par rapport aux approches concurrentes, est d'être facilement exprimable formellement, ce qui le rend particulièrement propice à l'écriture de preuves formelles.
Afin de renforcer la solidité des preuves d'algorithmes, cet article est accompagnés des preuves, qui ont été vérifiés par l'assistant de preuve Isabelle.

\section{Description du modèle}

\subsection{Présentation générale}

Dans le modèle Heard-Of, les processus sont décrits par des machines à états (voir définition formelle ci-dessous).
Le système est synchrone, c'est-à-dire que la progression du système est subdivisée en rounds. À chaque round, chaque processus :
\begin{itemize}
	\item envoie aux autres un messages, en fonction de l'état dans lequel il se trouve,
	\item reçoit un sous-ensemble des messages envoyés par ses pairs \emph{au cours de ce même round},
	\item modifie son état, en fonction des mesaages reçus, et de son état antérieur.
\end{itemize}

Pour une exécution donnée (voir définition formelle ci-dessous), la connectivité du réseau peut être décrite par une suite de graphes $(\mathds{G}_r)_{r \in \mathds{N}}$, appelée \textit{graphe dynamique} :
au round $r$, le processus $p$ est capable d'envoyer au processus $q$ si et seulement si le graphe $\mathds{G}_r$ contient l'arête $(p,q)$.

On ne peut résoudre aucun problème intéressant dans un tel système si on suppose que la connectivité est arbitrairement mauvaise. Dans le cas extrême, le graphe dynamique est une suite de graphes vides, 
donc aucune connexion ne fonctionne jamais.
On est donc amené à restreindre l'ensemble des graphes dynamiques possibles. Ces restrictions prennent généralement la forme de \emph{prédicats de communications}.

%Dans la litérature, on rencontre plusieurs façons de modéliser les pannes, par exemple l'article \cite{dds} envisage entre autre :
%\begin{itemize}

	%\item Les "crash-failure", c'est-à-dire les cas où des processus peuvent inopinément cesser de fonctionner.
	%\item Les échanges de messages, c'est-à-dire la réception des messages dans un ordre chronologiquement différent de l'envoi.

%\end{itemize}

Par exemple, pour modéliser un système sans aucune panne, il suffit de considérer le prédicat $\mathcal{P}_{complet}$, dans lequels tous les messages sont toujours livrés :

$$\mathcal{P}_{complet} \equiv \forall r \in \mathds{N}, \forall p \in \Pi, HO(p, r) = \Pi$$

Ici, $HO(p, r)$ désigne l'ensemble des voisins entrants de $p$ dans le graphe $\mathds{G}_r$.
Ce prédicat exprime le fait que, à chaque round, le graphe dynamique est complet.
Pour modéliser un système avec $k$ crash-failures, il suffit d'exprimer le fait qu'il existe à chaque round $r$ un quorum $S_r$ d'au moins $|\Pi| - k$ processus dont les messages sont toujours livrés,
Les processus ayant échoué ne sont plus jamais entendus.

$$\mathcal{P}_{k-crash} \equiv \exists (S_i)_{i \in \mathds{N}}, \forall r \in \mathds{N}, S_{r+1} \subseteq S_r \wedge |S_r| \geq |\Pi| - k \wedge (\forall p \in \Pi, HO(p, r) = S_r)$$.

L'objectif de cet article est d'établir des algorithmes de consensus ayant une très bonne résistance aux pannes. Pour cela, on s'intéressera particulièrement au prédicat suivant :

$$\mathcal{P}_{\xi-nek} \equiv \exists \xi \in \Pi, \forall r \in \mathds{N}, \forall p \in \Pi, \xi \in HO(p,r)$$.

Ce prédicat est au moins aussi fort que l'hypothèse $|\Pi| - 1$ crash-failures :
il exprime le fait qu'il existe au moins un processus fiable dans le réseau, qui parvient toujours à faire parvenir ses propres messages.
Ce processus, noté $\xi$ n'a pas besoin d'être connus par les autres processus du réseau.
Les autres processus peuvent fonctionner de manière totalement arbitraire.

Cette hypothèse sur le réseau est en fait très faible : un réseau avec aucun processus fiable serait un réseau de très mauvaise qualité. Cependant, on envisagera quand même des versions
davantage affaiblies de ce prédicat.

$$\mathcal{P}_{nek} \equiv \forall r \in \mathds{N}, \exists \xi \in \Pi, \forall p \in \Pi, \xi \in HO(p,r)$$.

Celle-ci tolère le fait qu'à chaque round, le processus supposé fiable peut être différent.

Pour augmenter la résistances aux échecs de communication, on introduit également les prédicats $\mathcal{P}_{T-rooted}$ et $\mathcal{P}_{rooted}$.
Ces prédicats expriment le fait qu'à chaque round, le graphe de communication contient un arbre couvrant tout le système.
Cet arbre est supposé fixe dans le cas de $\mathcal{P}_{T-rooted}$ (on le note $T$), mais peut varier au fil des rounds dans le cas de $\mathcal{P}_{rooted}$.
Ainsi, $\mathcal{P}_{\xi-rooted}$ (respectivement $\mathcal{P}_{rooted}$) est un cas particulier de $\mathcal{P}_{T-rooted}$ (respectivement $\mathcal{P}_{rooted}$) où $T$ est de profondeur 1.

\subsection{départs synchrones - départs asynchones}

L'objectif de cet article n'est pas d'étudier les systèmes ouverts, où des processus peuvent se joindre au réseau à tout moment.
On suppose donc qu'au round 0, tous les processus sont matériellement actifs. En revanche, il se pourrait qu'au round 0, tous les processus ne soient pas prêt à commencer l'algorithme.
Par exemple, dans le cas d'un algorithme de consensus, les processus commencent chacun avec une valeur initiale. Admettons que cette valeur initiale soit le résultat d'un calcul antérieur.
Dans ce cas, chaque processus ne connaîtra sa propre valeur initiale qu'à partir du round $s^0_p$ auquel ce calcul antérieur a terminé.
Tant que le processus n'est pas prêt à exécuter un certain algorithme, il se contente de rester passif vis à vis de cet algorithme,
et signale son attente envoyant un message noté $nil$ à tous les processus.
On appelle calendrier d'activation la suite croissante $(\mathcal{A}_r)_{r \in \mathds{N}}$. Au round $r$, $\mathcal{A}_r \subseteq \Pi$ est le sous-ensemble des processus actifs au round $r$.

En fonction de la nature des calculs antérieurss à exécuter, différentes hypothèses peuvent être faites sur le calendrier d'activation.
Ces hypothèses sont également exprimable sous forme de prédicats de communications.
Dans le cadre de ce document, on considèrera en particulier le prédicat suivant :

$$\mathcal{P}_{non-inf} \equiv \exists r \in \mathds{N}, \mathcal{A}_r = \Pi$$

Ce prédicat signifie qu'à partir d'un certain rang $r$, tous les processus sont actifs.

\subsection{Définition d'un algorithme}

On se donne un ensemble non vide $\Pi$ de cardinalit\'e $n$ et  un ensemble non vide ${\cal M}$ dont les \'el\'ements seront appel\'es des
	messages et un \'el\'ement particulier {\em nil} qui n'est pas dans $\mathcal{M}$.
A chaque  $p \in \Pi$,  on associe  un {\em processus} consistant en la donn\'ee des \'el\'ements 
	suivants :
	\begin{itemize}
	\item un ensemble non vide $States_p$ et un  \'el\'ement $sleep_p \notin States_p$ ;
	\item un sous-ensemble   $Init_p \subseteq States_p$ ;
	\item une fonction $S_p : States_p \times \Pi \rightarrow \mathcal{M}$ ;
	\item une fonction 
		$T_p : States_p \times X_\Pi^\mathcal{M}
	  \rightarrow States_p$,
	  où  $X_\Pi^\mathcal{M}$ est le type d'une fonction partielle
			de type $\Pi \rightarrow \mathcal{M}$, pouvant prendre la valeur supplémentaire notée $nil \notin \mathcal{M}$.
	\end{itemize}
Les \'el\'ements de 	$States_p$  sont appel\'es \emph{\'etats} de $p$, ceux de $Init_p$ \emph{\'etats initiaux} de $p$,
	la fonction $S_p$ est appel\'ee \emph{fonction d'émission de} $p$ et la fonction $T_p$ \emph{fonction de transition de} $p$.

\begin{definition}\label{def:algo}
Un algorithme  sur $\Pi$ est la donn\'ee d'un processus $(States_p, Init_p, S_p,T_p)$ pour chaque  \'el\'ement $p \in \Pi$.
\end{definition}
\noindent Dans toute la suite, on confondra et notera de la m\^eme mani\`ere $p$ et le processus qui lui est associ\'e.

\subsection{Définition générique d'une exécution}

Dans le mod\`ele Heard-Of, le calcul \'evolue en \emph{round} : dans chaque round $r$, 
	le processus $p$, s'il est actif,  
	\begin{enumerate}
	\item \'emet, \`a destination de chaque processus, un message qui est d\'etermin\'e par sa fonction d'\'emission~$S_p$  
		appliqu\'ee \`a son \'etat courant ;
	\item re\c{c}oit un message, \'emis au round $r$, d'un sous-ensemble de processus $HO(p,r)$ de $\Pi$ ;
        \item  applique la fonction  $T_p$ \`a son \'etat courant  et au vecteur (partiel) form\'e par les messages re\c{c}us (dont le support est 
         $HO(p,r)$).
	\end{enumerate}
Si le processus $p$ est passif au round~$r$ alors il \'emet le message $nil$ et reste dans l'\'etat $sleep_p$.
Un processus ne peut devenir actif qu'au d\'ebut d'un round, auquel cas son \'etat passe de $sleep_p$ \`a 
	un \'etat de $Init_p$.
La donn\'ee de l'ensemble $HO(p,r)$ pour chaque processus $p \in \Pi$ est \'equivalente \`a celle du graphe dirig\'e
	$\mathds{G}_r = (\Pi, E_r)$ dont l'ensemble des n\oe uds est $\Pi$ et dont l'ensemble $E_r$ des arcs dirig\'es 
	est d\'efini par
	$$ (q,p) \in E_r \Leftrightarrow q \in HO(p,r) .$$	
Le graphe $\mathds{G}_r $ correspond exactement aux communications entre processus au round~$r$.
Nous ne discutons pas ici des raisons de l'absence de communication de $q$ vers $p$ \`a un round et reportons pour cela  le lecteur 
	\`a~\cite{CB09} dans le cas d'un syst\`eme avec des pannes b\'enignes.

Formellement, une \emph{ex\'ecution} de l'algorithme  $(States_p, Init_p, S_p,T_p)_{p\in \Pi}$ est 
	un triplet $\big( \mathds{G} ,  \mathcal{A} , (\sigma^0_p)_{p \in \Pi} \big)$ où :
	\begin{itemize}
	\item $\mathds{G}$ est un \emph{graphe dynamique} sur $\Pi$, i.e., une suite infinie de graphes dirig\'es 
	$\mathds{G}_r = (\Pi, E_r)$ dont l'ensemble des n\oe uds est $\Pi$ ; 
	\item le \emph{calendrier des activations} $\mathcal{A} = (\mathcal{A}_r)_{r \in \mathds{N}}$ est une suite 
	croissante de sous-ensembles de $\Pi$ 
	avec $\mathcal{A}_0 = \emptyset$ ;
	\item pour chaque processus $p\in \Pi$, $\sigma^0_p \in Init_p$.
	\end{itemize}
Ici,  $\mathcal{A}_r \subseteq \Pi$ modélise le sous-ensemble des processus actifs au round~$r$.
La suite est croissante car, l'\'etat actif est stable : une fois r\'eveill\'e, un processus reste actif pour toujours.

\textbf{Remarques :}
\begin{itemize}
	\item Les départs sont synchones lorsque tous les processus deviennent actifs au même round, i.e.,
	$$ \forall r \in \mathds{N}, \mathcal{A}_r \in \{\emptyset, \Pi\}  . $$
	\item La donn\'ee de la suite $(\mathcal{A}_r)_{r \in \mathds{N}}$ est  équivalente \`a celle de la fonction 
	$s : \Pi \rightarrow \mathds{N} \cup \{\infty\}$ où 
	$$ s(p) = \left \{ \begin{array}{l ll}
	                          \infty & \mbox{ si  } p \notin \bigcup\limits_{r \in \mathds{N}}  \mathcal{A}_r &  \mbox { ($p$ reste passif) } \\
	                          r  & \mbox{ si  } p \notin \mathcal{A}_{r-1} \mbox{ et } p \in \mathcal{A}_{r}  & \mbox{ ($p$ devient actif au round $r$)}.
	                          \end{array} \right.$$ 
	\item On note $HO(p,r)$ l'ensemble des processus actifs entendus par le processus p au round n : $HO(p,r) = \{q, (q,p) \in E_r\}$
	\item On note $HO_{actif}(p,r)$ l'ensemble des processus actifs entendus par le processus p au round n : $HO_{actif}(p,r) = HO(p,r) \cap \mathcal{A}_r$.

\end{itemize}

Pour toute  exécution de l'algorithme  $(States_p, Init_p, S_p,T_p)_{p\in \Pi}$, on définit inductivement la collection 
	d'\'etats $ \big( \Gamma_p(r) \big )_{p\in\Pi, r\in \mathds{N}}$ de la fa\c{c}on suivante : 
	\begin{itemize}
		\item $\forall r \in \mathds{N},\forall p \in \Pi \setminus \mathcal{A}_{r+1}, \  \Gamma_p(r) = sleep_p$ ;
		\item $\forall r  \in \mathds{N},\forall p \in \mathcal{A}_{r+1} \setminus \mathcal{A}_r, \ \Gamma_p(r) = \sigma^0_p$ ;
		\item $\forall r  \in \mathds{N},\forall p \in \mathcal{A}_{r} , \  \Gamma_p(r) = T_p (\Gamma_p(r - 1) ,M_p^{r})$
			où $M_p^r$ est la fonction partielle de type $X_\Pi^\mathcal{M}$ définie par 
			$$ M_p^r(q) = \left \{ \begin{array}{l l}
	                         nil  & \mbox{ si  } q \in (\Pi \setminus \mathcal{A}_r  ) \cap  HO(p,r)  \\
	                         S_q (\Gamma_q(r), p)  & \mbox{ si  }   q \in \mathcal{A}_r  \cap  HO(p,r) \\
	                         \mbox{ non d\'efini  } & \mbox{ si  }   q \notin  HO(p,r) .
	                          \end{array} \right.$$ 
	\end{itemize}
Dorénavant, $M_p^r$ est appelée \emph{fonction de réception de $p$ au round $r$}.

\subsection{Probl\`eme du Consensus}

	Soit un ensemble de valeurs $\mathcal{V}$ non vide.
	On considère un algorithme $A$ dans lequel les processus reçoivent, lors de leur activation, une valeur initiale $v_p \in \mathcal{V}$,
	et qui prennent, à un round donné, une valeur de décision, également dans $\mathcal{V}$.
	On décrit la valeur initiale des processus à l'aide de la fonction $Val : \bigcup\limits_{p \in \Pi} Init_p  \rightarrow \mathcal{V}$.
	Ainsi, pour une exécution donnée, $v_p = Val(\sigma_p^0)$
	On décrit la valeur de décision des processus à l'aide d'une fonction
	$Dec : \bigcup\limits_{p \in \Pi} States_p  \rightarrow (\mathcal{V} \uplus \{\bot\})$.
	Ainsi, si $p$ a décidé $v$ au round $r$, on a $Dec(\Gamma_p(r)) = v$. Si $p$ n'a pas encore décidé au round $r$, on a $Dec(\Gamma_p(r)) = \bot$.

\begin{definition}
	Une exécution de A \emph{vérifie  l'intégrité} si 
	$$ \forall r \in \mathds{N},\forall p \in \mathcal{A}_{r}, \ Dec(\Gamma_p(r)) \in \{ \bot \} \cup  \{ Val(\sigma^0_q) :  q \in \Pi \}  .$$
\end{definition}

\begin{definition}
	Une exécution de A  \emph{vérifie l'accord} si
	$$\forall r, r'  \in \mathds{N}, \forall p \in \mathcal{A}_{r}, \forall q \in \mathcal{A}_{r'}, 
		\ Dec(\Gamma_p(r)) = \bot \vee Dec(\Gamma_q(r')) = \bot \vee Dec(\Gamma_p(r)) = Dec(\Gamma_q(r')) .$$
\end{definition}

\begin{definition}
	Une exécution de A \emph{vérifie la terminaison} si
	$$ \forall p \in \bigcup\limits_{s \in \mathds{N}} \mathcal{A}_s, \exists r \in \mathds{N}, \ 
		p \in \mathcal{A}_r \wedge Dec(\Gamma_p(r)) \neq \bot .  $$
\end{definition}

On considère deux prédicats $\mathcal{P}_{\mathds{G}}$ et $\mathcal{P}_{cal}$.
Ce premier prédicat définit une famille de graphe dynamique, et le second une famille de calendrier d'activation.
	
\begin{definition}\label{def:resforte}
	Un algorithme \emph{résout le consensus sous $\mathcal{P}_{\mathds{G}}$ et $\mathcal{P}_{cal}$} si toute exécution 
	$( \mathds{G} ,  \mathcal{A} , (\sigma^0_p)_{p \in \Pi})$    de cet algorithme
	avec $ \mathds{G} \models \mathcal{P}_{\mathds{G}}$ et $\mathcal{A}	\models \mathcal{P}_{cal}$  vérifie l'intégrité, l'accord et la terminaison.
\end{definition}


\subsection{Hypothèses de connaissance}

\begin{definition}
	On dit qu'un processus $p$ \textit{connaît} une variable $h$ si la fonction d'émission $S_p$, ou la fonction de transition $T_p$ dépend de $h$. 
\end{definition}

La connaissance qu'ont les processus sur les caractéristiques du système peuvent fortement influer sur la résolubilité de problèmes comme le consensus.
Il est parfois nécessaire que les processus connissent la taille du réseau $n$ pour que le consensus soit résoluble.
À défaut de connaitre $n$, il est parfois utile que les processus connissent une borne supérieure $\mathcal{N}$ sur la taille du réseau.

\begin{definition}
	On dit qu'un réseau est \textit{identifié} si les processus connaissent un identifiant $x_p$, unique à chaque processus.
	Un réseau non identifié est dit \textit{anonyme}.
\end{definition}

\section{Théorèmes de résolubilité}

On considère un prédicat $\Phi$ sur un graphe. On définit les transformateurs de prédicats de la manière suivante.

\begin{definition}
	On définit le prédicat $P_k(\Phi)$ sur un graphe dynamique
	$\mathds{G}$ par $$P_k(\Phi) \equiv \forall t \in \mathds{N}, \mathds{G}(t:t+k) \models \Phi$$
\end{definition}

$\Phi$ est toujours équivalent à $P_k(\Phi)$, puisqu'on peut trivialement construire un algorithme $A_k$ qui traduise $P_k(\Phi)$ en $\Phi$.

\begin{definition}
	On définit le prédicat $P_{borné}(\Phi)$ sur un graphe dynamique
	$\mathds{G}$ par $$P_{borné}(\Phi) \equiv \exists b \in \mathds{N}, \forall t \in \mathds{N}, \mathds{G}(t:t+b) \models \Phi$$
\end{definition}
\begin{definition}
	On définit le prédicat $P_{fini}(\Phi)$ sur un graphe dynamique
	$\mathds{G}$ par $$P_{fini}(\Phi) \equiv  \forall t \in \mathds{N}, \exists b \in \mathds{N}, \mathds{G}(t:t+b) \models \Phi$$
\end{definition}

Le prédicat $\mathcal{P}_{borné}(\Phi)$ est une version affaiblie de $\Phi$, où $\Phi$ est vérifié avec délai borné, mais inconnu des processus.
Le prédicat $\mathcal{P}_{fini}(\Phi)$ est une version davantage affaiblie de $\Phi$, où $\Phi$ est vérifié avec délai inconnu des processus, et pouvant varier au cours du temps.

On définit les prédicats suivants :
\begin{itemize}
	\item Le graphe $G = (V, E)$ vérifie le prédicat $\Phi_{nek}$ si et seulement si $\exists p \in \Pi, \forall q \in \Pi, (p, q) \in E$.
	\item Le graphe dynamique $\mathds{G}$ vérifie le prédicat $\mathcal{P}_{nek}$ si pour tout $\forall n \in \mathds{N}, \mathds{G}_n \models \Phi_{nek}$. 
	\item Étant donné $\xi \in \Pi$. Le graphe $G = (V, E)$ vérifie le prédicat $\Phi_{\xi-nek}$ si et seulement si $\forall q \in \Pi, (\xi, q) \in E$.
	\item Le graphe dynamique $\mathds{G}$ vérifie le prédicat $\mathcal{P}_{\xi-nek}$ si pour tout $\forall n \in \mathds{N}, \mathds{G}_n \models \Phi_{\xi-nek}$. 
	\item Le calendrier d'activation $\mathcal{A}$ vérifie le prédicat $\mathcal{P}_{non-inf}$ si et seulement si $\exists k \in \mathds{N}, \mathcal{A}_k = \Pi$.
\end{itemize}

\subsection{Théorèmes d'impossibilité}

Ce premier théorème montre que le prédicat $\mathcal{P}_{non-inf}$ est indispensable pour la résolution du consensus dans un graphe avec étoile recouvrante.

\begin{theorem}
	Il n'existe pas d'algorithme qui résolve le consensus sous le prédicat $\mathcal{P}_{\xi-nek}$, même si les processus connaissent la taille du réseau.
\end{theorem}
\begin{proof}
	On suppose qu'un tel algorithme existe, et on construit une exécution qui viole l'accord.

	\begin{description}
		\item[Exécution 0 : ] Le graphe dynamique est une étoile constante, centrée sur $\xi$. $\xi$ est passif pour toujours. Les autres processus ont 0 comme valeur initiale.
			Et ils s'activent en temps fini. La terminaison assure qu'il décident tous 0 en temps fini.

		\item[Exécution 1 : ] Le graphe dynamique est une étoile constante, centrée sur $\xi$. $\xi$ est passif pour toujours. Les autres processus ont 1 comme valeur initiale.
			Et ils s'activent en temps fini. La terminaison assure qu'il décident tous 1 en temps fini.

		\item[Exécution 2 : ] Le graphe dynamique est une étoile constante, centrée sur $\xi$. $\xi$ est passif pour toujours. Les autres processus ont différentes valeurs initiales.
			En particulier, un processus $p_0$ a 0 comme valeur initiale, et $p_1$ a 1.
			Et ils s'activent en temps fini. Pour $p_0$, ce scénario est indistinguable du scénario 0, donc $p_0$ décide 0.
			Pour $p_1$, ce scénario est indistinguable du scénario 1, donc $p_1$ décide 1.  Cela viole l'accord.
	\end{description}
\end{proof}

Ce deuxième théorème montre que la racine de l'étoile recouvrante doit être fixe pour que le consensus soit résoluble.

\begin{theorem}
	Il n'existe pas d'algorithme qui résolve le consensus sous les prédicats $\mathcal{P}_{nek}$ et $\mathcal{P}_{non-inf}$, même si les processus connaissent la taille du réseau.
\end{theorem}
\begin{proof}
	On suppose qu'un tel algorithme existe, et on construit une exécution qui viole l'accord.
	Soient $p_1, p_2 \in \Pi$.
	\begin{description}

		\item[Exécution 1 :] $\mathds{G}_r$ est pour tout $r$ égal à l'étoile centrée en $p_1$. $p_1$ s'active en temps fini, donc la terminaison assure que $p_1$ décidera en un round $t$.
		\item[Exécution 2 :] Pour tout $r \leq t$, $\mathds{G}_r$ est l'étoile centrée en $p_1$. $p_1$ s'active au même round que dans l'exécution précédente.
			Pour tout $r > t$, $\mathds{G}_r$ est l'étoile centrée en $p_2$. On suppose que $p_2$ s'active au round $t+1$.
			Dans ces conditions, $p_2$ ne reçoit jamais de message. La terminaison et l'intégrité assurent que $p_2$ décide finalement sa valeur initiale,
			tandis que $p_1$ a déjà décidé. Dans ces conditions, l'accord est impossible à assurer.

	\end{description}
\end{proof}

Enfin, ce dernier théorème montre que le prédicat $\mathcal{P}_{\xi-nek}$ doit être vérifié à chaque round, et non après un certain délai inconnu des processus.

\begin{theorem}
	Il n'existe pas d'algorithme qui résolve le consensus sous les prédicats $P_{borné}(\Phi_{\xi-nek})$ et $\mathcal{P}_{non-inf}$, même si les processus connaissent la taille du réseau.
\end{theorem}
\begin{proof}
	On suppose qu'un tel algorithme existe, et on construit une exécution qui viole l'accord.
	Soient $p_1, p_2 \in \Pi$.
	\begin{description}

		\item[Exécution 1 :] $\mathds{G}_n$ est pour tout $n$ égal à l'étoile centrée en $p_1$. On exécute l'algorithme $A$.
			$p_1$ s'active en temps fini, donc la terminaison assure que $p_1$ décidera en un round $r_1$.
		\item[Exécution 2 :] $\mathds{G}_n$ est pour tout $n$ égal à l'étoile centrée en $p_2$. On exécute l'algorithme $A$.
			$p_2$ s'active en temps fini, donc la terminaison assure que $p_2$ décidera en un round $r_2$.
		\item[Exécution 3 :] Pour tout $n \leq r_0 + r_1$, $\mathds{G}_n$ est le graphe sans aucune arête. Pour tout $n > r_0 + r_1$, $\mathds{G}_n$ est l'étoile centrée en $p_1$.
			$p_1$ et $p_2$ s'activent au même round que lors des deux précédentes exécutions.
			Pour $p_1$, ce scénario est indistinguable du scénario 1, donc $p_1$ décidera au round $r_1$.
			Pour $p_2$, ce scénario est indistinguable du scénario 1, au moins jusqu'au round $r_2$. Donc $p_2$ décidera au round $r_2$.
			Dans ces conditions, l'accord est impossible à assurer.

	\end{description}
\end{proof}

\subsection{Exécution en série}

Pour la section suivant, on aura besoin de la notion d'exécution en série d'algorithme.
Intuitivement, étant donné deux algorithmes $A$ et $B$, l'algorithme $A;B$ consiste à exécuter $A$, et dès que $A$ atteint un état final, commencer à exécuter $B$.

On suppose donné un algorithme $A = (States_p^A, Init_p^A, S_p^A, T_p^A)$ et un algorithme $B = (States_p^B, Init_p^B, S_p^B, T_p^B)$ (voir document sur la preuve de "one-third rule").
On suppose que $States_p^A$ contient un sous-ensemble $F \subseteq States_p^A$ d'états finaux. On suppose que $T_p^A$ est stable sur $F$.

\begin{definition}
	On définit l'algorithme $A;B$ comme le tuple $(States_p^{AB}, Init_p^{AB}, S_p^{AB}, T_p^{AB})$ où :
	\begin{itemize}

		\item $States_p^{AB} = (States_p^A \times Init_p^B) \cup (F \times States_p^B)$
		\item $Init_p^{AB} = Init_p^A \times Init_p^B$
		\item $S_p^{AB}$ définit par, pour tout $s = (s_A, s_B)$, 
			$$S_p^{AB}(s) = \left \{ \begin{array}{l ll}
				\langle S_p^A(s_A), nil        \rangle & \mbox{si}~s_A \notin F & \{A~\mbox{en cours d'exécution}\} \\
				\langle S_p^A(s_A), S_p^B(s_B) \rangle & \mbox{si}~s_A \in F    & \{B~\mbox{en cours d'exécution}\} \end{array} \right$$
			\item $T_p^{AB}$ définit par, pour tout $s = (s_A, s_B) \in States_p^{AB}$, pour tout $M = (M_A, M_B)$, 
			$$T_p^{AB}(s, M) = \left \{ \begin{array}{l ll}
				\langle T_p^A(s_A, M_A), s_B             \rangle & \mbox{si}~s_A \notin F & \{A~\mbox{en cours d'exécution}\} \\
				\langle T_p^A(s_A, M_A), T_p^B(s_B, M_B) \rangle & \mbox{si}~s_A \in F    & \{B~\mbox{en cours d'exécution}\} \end{array} \right$$

	\end{itemize}
\end{definition}

\subsection{Algorithme "Uniforme Voting"}

Il reste maintenant à traiter le cas le plus favorable, à savoir le cas où les prédicats $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
Ci-dessous se trouve l'algorithme "Uniforme Voting", tiré de \cite{model_ho}.
Cet algorithme est consitué de deux phases qui alternent en fonction de la parité du round :
\begin{itemize}
	\item Une phase durant laquelle les processus échangent leurs valeurs (lignes 21-23).
	\item Une phase durant laquelle les processus votent pour leur valeur, et décident en cas d'unanimité (lignes 13-19).
\end{itemize}

Bien qu'initialement conçu pour fonctionner lorsque les départs sont synchrones, on peut aisément adapter cet algorithme pour tolérer les départs asynchrones.
Il s'agit simplement de préciser comment prendre en charge les $nil$ envoyés par les processus passifs.

Cependant, cette simple transposition ne suffit pas à rendre l'algorithme tolérant au départs asynchrones. Le problème est le suivant :
Si un processus s'active à un round pair, sa phase d'échange de valeur aura lieu à chaque round impair, et sa phase d'échange de vote à chaque round pair.
À l'inverse,
si un processus s'active à un round impair, sa phase d'échange de valeur aura lieu à chaque round pair, et sa phase d'échange de vote à chaque round impair.
Donc si les processus du réseau démarrent à des rounds ayant différentes parité, on aura, au sein d'un même round,
des processus qui feront leur phase d'échange de valeur, et d'autre leur phase d'échange de vote.
Dans ces conditions, la sûreté de l'algorithme ne tient plus.

Il s'agit donc de faire en sorte que tous les processus s'activent à des rounds ayant tous la même parité. 
On appelle cela le \emph{problème de synchronisation modulo 2}.
Comme ce problème fera l'objet d'une prochaine section, on va provisoirement supposer ce problème résolu en supposant vrai le prédicat 

$$\mathcal{P}_{sync-mod-2} \equiv \exists c \in \{0, 1\}, \forall k \in \mathds{N}, \mathcal{A}_{2k+c} = \mathcal{A}_{2k+c+1}$$

Voici maintenant l'algorithme "Uniforme Voting	Voting" et sa preuve de correction.

\begin{algorithm}[htb]
\scriptsize{
\begin{distribalgo}[1]
\begin{tabular}{ll}
\begin{minipage}{33em}


\INDENT{\textbf{Initialization:}}
  \STATE $x_p := v_p$ ~~~~~~~~\{\emph{$v_p$ is the initial value of $p$}\}
  \STATE $vote_p \in V\cup\{ ? \}$, initially $?$
  \STATE $phase_p = true$

\ENDINDENT
\BLANK

\INDENT{\textbf{Round $r$:}}
	\INDENT{$S_p^r:$}
		\IF{$phase_p$}
			\STATE send $\langle x_p , vote_p \rangle$ to all processes
		\ELSE
			\STATE send $\langle x_p \rangle$ to all processes
		\ENDIF
	\ENDINDENT
	\BLANK
	\INDENT{$T_p^r:$}

		\IF{$phase_p$}
			\IF{$M(q) = \langle v, v \rangle$}
				\STATE $x_p:= v$ ~~~~~~~~\{un vote reçu\}
			\ELSE
				\STATE $x_p :=$ smallest  $w$ from  $\langle w , ? \rangle$ received
			\ENDIF
			\IF{$M(\Pi) = \langle v, v \rangle$}
				\STATE $DECIDE(v)$ ~~~~~~~~\{décider si $p$ ne reçoit que des votes identiques\}
			\ENDIF
			\STATE $vote_p :=\ ?$
		\ELSE
			\STATE $ x_p := min M(\Pi) \setminus \{nil\}$ ~~~~~~~~\{plus petites valeur reçue\}
			\IF{$M(\Pi) = \{v\}$}
				\STATE $vote_p := v$ ~~~~~~~~\{toute les valeurs reçues identiques, aucun nil\}
			\ENDIF
		\ENDIF
		\STATE $phase_p := \neg phase_p$
	\ENDINDENT
\ENDINDENT

\end{minipage}
\end{tabular}

\caption{The {\em UniformVoting} algorithm}
\label{unifvotfig}
\end{distribalgo}
}
\end{algorithm}

\subsubsection{Intégrité}
\begin{lemma}
	Toute exécution de l'algorithme "Uniforme Voting" vérifie l'intégrité lorsque le prédicat $\mathcal{P}_{sync-mod-2}$ est vérifié.
\end{lemma}
\begin{proof}
	Il suffit de montrer par récurrence qu'à chaque round, les valeurs stockées dans les processus actifs appartiennent nécessairement à l'ensemble des valeurs initiales.
\end{proof}

\subsubsection{Accord}

\begin{lemma}
	Toute exécution de l'algorithme "Uniforme Voting" vérifie l'accord lorsque le graphe dynamique vérifie le prédicat $\mathcal{P}_{\xi-nek}$
	et le calendrier d'activation vérifie $\mathcal{P}_{sync-mod-2}$.
\end{lemma}
\begin{proof}
	Si un processus $p$ décide une valeur $v$ au round $r$, nécessairement, le processus $\xi$ au centre de l'étoile a voté $v$ au round $r$.
	Donc, au round $r$, tous les processus actifs adoptent $v$.
	Donc toute valeur décidée ultérieurement sera nécessairement $v$. Pour s'en convaincre, on montre aisément par récurrence sur $k$ la proposition suivante :
	$$\forall k \in \mathds{N}, \forall q \in \mathcal{A}_{r+2k}, vote_p(2k) = v \wedge x_q(r+2k) = v \wedge x_q(r+2k+1) = v$$.

	Cela achève l'accord.
\end{proof}

\subsubsection{Terminaison}

	\begin{lemma}
		Étant donné une exécution vérifiant $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{sync-mod-2}$.
		Soit $r$ le round auquel $\xi$, le centre de l'étoile, s'active.
		La suite $(x_\xi(r+k))_{k \in \mathds{N}}$, représentant la succession des valeurs de $\xi$, est décroissante.
	\end{lemma}
	\begin{proof}
		Soit $k \in \mathds{N}$. Soit $M$ la fonction de réception de $\xi$ au round $r+k+1$.
		\begin{itemize}

			\item Si $k+1$ est impair, la ligne 19 du pseudo-code assure que $x_\xi(r+k+1) = min(M(\Pi) \setminus \{nil\})$.
				Or $M(\xi) = x_\xi(r+k)$.  Donc $x_\xi(r+k+1) \leq x_\xi(r+k)$.
			\item Si $k+1$ est pair et si $\exists q \in \mathcal{A}_{r+k+1}, M(q) = \langle v, v \rangle$,
				on a nécessairement $v = x_\xi(r+k)$, puisque $\xi$ a envoyé $x_\xi(r+k)$ au round $r+k$ (cf. lignes 20-21).
				Donc $x_\xi(r+k+1) = x_\xi(r+k)$.
			\item Sinon la ligne 11 du pseudo-code assure que $x_\xi(r+k+1) = min(M(\Pi) \setminus \{nil\})$.
				Or $M(\xi) = \langle x_\xi(r+k), * \rangle$.
				Donc $x_\xi(r+k+1) \leq x_\xi(r+k)$.

		\end{itemize}
		Dans tous les cas, $x_\xi(r+k+1) \leq x_\xi(r+k)$.
	\end{proof}
		

	\begin{lemma}
		Toute exécution de "Uniforme Voting" vérifie la terminaison lorsque le graphe de communication vérifie $\mathcal{P}_{\xi-nek}$
		et lorsque le calendrier d'activation vérifie $\mathcal{P}_{non-inf}$ et $\mathcal{P}_{sync-mod-2}$.
	\end{lemma}
	\begin{proof}
		Soit $r_0$ le round auquel tous les processus sont actifs.

		La suite $(x_\xi(r_0+k))_{k \in \mathds{N}}$ est décroissante et ne contient que des valeurs initiales. Donc elle se stabilise sur une valeur $v$ à partir d'un certain round $r_0+k_0$.
		On considère maintenant le round $r_0+2k_0$, qui est un round d'échange de vote.
		$\xi$ envoie $\langle v, * \rangle$ à tous les processus. Les lignes 8 à 11 du pseudo-code assurent que $\forall q \in \mathcal{A}_{r_0+2k_0}, x_q(r_0+2k_0) \leq v$.

		Soit $M$ la fonction de réception de $\xi$ lors du round $r_0+2k_0+1$.
		Comme $x_\xi(r_0+2k_0+1) = v$, la ligne 19 assure que $\xi$ n'a pas reçu de message inférieur à $v$.
		Donc $M(\Pi) = \{v\}$. Donc $vote_\xi(r_0+2k_0+1) = v$. Donc au round $r_0+2k_0+2$, la ligne 9 assure que tous les processus adoptent $v$.

		Au rounds $r_0+2k_0+3$, les processus ne reçoivent que des messages contenant $v$, donc au rounds $r_0+2k_0+4$, tous les processus votent $v$, donc tous les processus décident.
	\end{proof}
\subsection{Résultat}

Les trois sections précédentes permettent d'affirmer le théorème suivant :

\begin{theorem}
	L'algorithme "Uniforme Voting" résout le consensus lorsque les prédicats$\mathcal{P}_{sync-mod-2}$, $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}

\section{Problème de synchonisation modulo $k$}

Le but de cette section est de proposer un algorithme permettant de synchroniser les différentes phases malgré les départs asynchrones.
L'algorithme qui sera présenté s'inspire de l'algorithme du "firing squad" \cite{firing_squad}.
Dans l'algorithme du firing-squad, les processus ont chacun un compteur, qu'ils imcrémentent à chaque round. Ils partagent la valeur de leur compteur à tous leur voisins sortant, 
et s'ils reçoivent plusieurs valeurs en conflits, ils adoptent la valeur minimale.
Si, pour un processus $p$, le compteur dépasse une certaine valeur, $p$ décide alors de \emph{faire feu}.
Si le graphe dynamique est constamment fortement connexe, on peut montrer que tous les processus font feu au même round.

Dans l'algorithme présenté ci-dessous, les compteurs sont dans $\mathds{Z}/k\mathds{Z}$ plutôt que dans $\mathds{N}$.
On montrera que, dans ce cas, tous les processus font feu lors des round mutuellement congrus modulo $k$.

\begin{definition}

	Soit un paramètre $k > 1$. Soit $s_{exit} \in States_p$ un état final.
	Étant donnée une exécution d'un algorithme $A$, pour tout $p \in \Pi$, on note $t_p$ le round auquel $p$ atteint $s_{exit}$ ($t_p = \infty$ sinon).
	Cette exécution de l'algorithme $A$ est sûr vis à vis du problème de synchronisation modulo $k$ si,
	$$\exists c \in \mathds{N}, \forall p \in \bigcup\limits_{i \in \mathds{N}} \mathcal{A}_i, t_p \neq \infty \Rightarrow t_p~mod~k = c$$

\end{definition}

\begin{definition}

	Une exécution de l'algorithme $A$ vérifie la vivacité vis à vis du problème de synchronisation modulo $k$ si,
	$$\forall p \in \bigcup\limits_{i \in \mathds{N}} \mathcal{A}_i, t_p \neq \infty$$

\end{definition}
\begin{definition}
	L'algorithme $A$ résoud le problème de synchronisation modulo $k$, si toute exécution de $A$ est sûre et termine.
\end{definition}

Pour la suite, on considère une valeur $k > 2$ quelquonque.

\subsection{Algorithme}

L'objectif est de résoudre ce problème dans les conditions suivantes :
\begin{itemize}

	\item Le graphe dynamique contient une étoile fixe : $\mathcal{P}_{\xi-nek} \equiv \exists \xi \in \Pi, \forall p \in \Pi, \forall r \in \mathds{N}, \xi \in HO(p, r)$
	\item Tous les processus s'activent en temps fini : $\mathcal{P}_{non-inf} \equiv \exists r \in \mathds{N}, \mathcal{A}_r = \Pi$

\end{itemize}

L'idée de l'algorithme ci-dessous est que chaque processus possède un compteur modulo $k$. À chaque round, il incrémente son compteur, et l'envoie à tous.
Il reçoit alors les valeurs de compteur de tous ses voisins entrants. Il essaye de se synchroniser avec les autres processus s'ils s'accordent tous sur une même valeur de compteur
(deuxième branche dans la fonction de transition).

Sinon, il fait une tentative de "synchronisation forcée", c'est-à-dire il essaye de convaincre tous les processus de se synchroniser sur son propre compteur :
il adopte la valeur $k$ (troisième branche). Au prochain round, il envoie $k$.  Les processus qui reçoivent ce $k$ sont obligés d'adopter 1 (quatrième branche).
Chaque processus ne fait qu'une seule fois cette tentative de synchronisation forcée (la variable $try_p$ sert justement à limiter $p$ à une seule tentative).
On note $t_p$ le round auquel le processus $p$ exécute cette branche, si cela se produit. $t_p = 0$ sinon.

Lorsqu'un processus s'active, il essaye de s'aligner sur les valeurs qu'il entend, avant d'envoyer sa propre valeur.
On introduit donc une valeur $\bot$, qui sera envoyé lors du round d'activation, qui sera traité comme un $nil$ par les processus récepteurs.

\pagebreak[1]

\begin{algorithm}[htb]
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
	\STATE $x_p \in \mathds{Z}/k\mathds{Z}$
	\STATE $try_p = true$
	\STATE $fire_p = false$

\ENDINDENT \BLANK

\INDENT{\textbf{Round 0:}}
 \INDENT{$S_p:$}
    \STATE send $\bot$ to all processes
  \ENDINDENT
\ENDINDENT
  \BLANK
\INDENT{\textbf{Round $r+1$:}}
 \INDENT{$S_p:$}
    \STATE send $\langle x_p \rangle$ to all processes
  \ENDINDENT
\ENDINDENT
  \BLANK
\INDENT{\textbf{Round $r$:}}
	\INDENT{$T_p(M):$}
	\IF{$M(\Pi) = \{k\}$}
	\STATE $fire_p = true$ ~~~~\COMMENT{si tous les messages reçus valent 0, aucun $nil$, l'algorithme fait feu}
	\ENDIF
	\IF{$M(\Pi) \setminus \{nil, \bot\} = \{v\}$}
	\STATE $x_p = v+1~mod~k$ ~~~~\COMMENT{si tous les messages ont la même valeur, s'aligner}
	\ELSIF{$try_p \wedge k \notin M(\Pi)$}
	\STATE $try_p = false$ ~~~~\COMMENT{si plusieurs messages sont discordants, faire une tentative de synchronisation forcée}
	\STATE $x_p = k$
	\ELSE
	\STATE $x_p = 1$ ~~~~\COMMENT{si un k a été reçu, toujours s'aligner}
	\ENDIF
  \ENDINDENT
\ENDINDENT 
\caption{The {\em SyncMod} algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

\subsection{Notations}

Soit $V \subseteq \mathds{Z}/k\mathds{Z}$. On dit que le système est V-valent au round $t$ si $V = \{v \in \mathds{Z}/k\mathds{Z}, \exists p \in \Pi, x_p(t) = v\}$.
On dit que le système est v-monovalent si le système est $\{v\}$-valent.

On dit que $p$ "fait feu" au round $t$ si $p$ exécute la première branche au round $t$.

\subsection{Preuve}

\begin{lemma}
	Si $x_\xi(t) = k$, le système est 1-monovalent au round $t+1$.
\end{lemma}
\begin{proof}
	$\xi$ est le centre de l'étoile.
	Si $x_\xi(t) = k$, au round $t+1$, $\xi$ envoie $k$ à tous les processus. Donc tous les processus, recevant un $k$, exécutent nécessairement la deuxième ou quatrième branche,
	et adoptent donc $1$. Le système devient donc 1-monovalent.
\end{proof}

\begin{lemma}
	Si, au round $s$, $\xi$ est actif, et le système est v-monovalent, pour tout $i \in \mathds{N}$, le système est $v+i~mod~k$-monovalent.
\end{lemma}
\begin{proof}
	On montre cela par récurrence sur $i$.
	\begin{description}
		\item[Initialisation :] Vrai par hypothèse.
		\item[Hérédité :] On suppose que $\forall p \in \mathcal{A}_{s+i}, x_p(s+i) = v+i~mod~k$.
			On veut montrer que $\forall p \in \mathcal{A}_{s+i+1}, x_p(s+i+1) = v+i+1~mod~k$.
			Au round $s+i+1$, les processus dans $\mathcal{A}_{s+i}$ envoyent $v+i~mod~k$, d'après l'hypothèse de récurrence.
			Les processus de $\mathcal{A}_{s+i+1} \setminus \mathcal{A}_{s+i}$ envoyent $\bot$. Les autres envoyent $nil$.
			Comme $\xi$ est actif, les processus reçoivent tous au moins une fois $v+i~mod~k$. Donc tous les processus actifs exécutent la deuxième branche, et adoptent $v+i+1~mod~k$.
	\end{description}
\end{proof}

\begin{lemma}
	Si $x_\xi(t) = k$, tout processus $p$ fait feu au plus tard au round $t+k i$ où $i$ est le plus petit entier vérifiant $t+k i \geq s_{max} = max \{s_p, p \in \Pi\}$.
\end{lemma}
\begin{proof}
	D'après les lemmes 1 et 2, le système devient 1-monovalent au round $t+1$ et $i~mod~k$-monovalent à tous les rounds $t+i$ suivants.
	À partir du round $s_{max}$, tous les processus sont actifs.
	Ainsi, au premier round $t+k i$ vérifiant $t+k i \geq s_{max}$, le système est $k$-monovalent, donc au round $t+k i +1$, tous les processus envoyent $k$ à leurs voisons sortants.
	Ainsi, les processus ne reçoivent que des $k$, donc tous les processus font feu.
\end{proof}

\begin{lemma}
	Si le système est monovalent au round $t$, tous les processus auront fait feu au plus tard au round $max(t, s_{max})+k$.
\end{lemma}
\begin{proof}
	D'après le lemme 2, le système est toujours monovalent au round $max(t, s_{max})$ et tous les processus sont actifs.
	Donc, au plus après $k$ rounds, le système entrera dans un état $k$-monovalent, et au round suivant, tous les processus enverront $k$.
	Ainsi, tous les processus qui n'auront pas encore fait feu, feront feu.
	Donc, au plus tard au round $max(t, s_{max})+k$, tous les processus auront fait feu.
\end{proof}

On introduit la fonction $C(t) = (x_\xi(t), \{v \in \mathds{Z}/k\mathds{Z}, \exists p \in \Pi, x_p(t) = v\})$.
Ainsi, si $C(t) = (v_0, V)$, le système est V-valent au round $t$.

On introduit un ensemble $\mathcal{F}$ de configurations dites "favorables".
Ainsi, $C(t) = (v, V) \in \mathcal{F} \equiv v = k \vee |V| = 1$.
Les deux lemmes précédents montrent que si une exécution atteint une configuration favorable, la vivacité est garantie.

\begin{lemma}
	Toute exécution de cet algorithme est sûr vis-à-vis du problème de synchronisation modulo k lorsque les prédicats $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{lemma}
\begin{proof}

	On suppose que $p$ fait feu au round $r$, et est le premier. Nécessairement, $\xi \in HO(p,r)$.
	La ligne 12 du code montre que la valeur envoyé par $\xi$ est 0.
	Donc tous les processus ont reçus un 0. Soit $p$ un processus actif quelquonque. Au round $r$, il execute, dans sa fonction de transition, l'une des quatre branches possibles.
	\begin{itemize}

		\item Il ne peut pas exécuter la troisième branche car $M(\xi) = 0$.
		\item S'il exécute la première, deuxième ou la quatrième branche, il adopte 0.

	\end{itemize}

	On montre maintenant par récurrence sur $i$ la proposition suivante :

	$$\forall i \in \mathds{N}, \forall p \in \mathcal{A}_{r+i}, x_p(r+i) = i~mod~k$$

	\textbf{Initialisation : } voir ci-dessus

	\textbf{Hérédité :}
	On suppose que $\forall p \in \mathcal{A}_{r+i}, x_p(r+i) = i~mod~k$.

	On veut montrer que $\forall p \in \mathcal{A}_{r+i+1}, x_p(r+i+1) = i+1~mod~k$.

	Soit $M$ la fonction de réception de $p$ au round $r+i+1$.
	L'hypothèse de récurrence montre que $M(\Pi) \subseteq \{nil, \bot, i+1~mod~k\}$.
	De plus, $M(\xi) = i+1~mod~k$. Donc $p$ exécute la première ou la deuxième branche de la fonction de transition, et adopte $i+1~mod~k$.
	Cela achève la récurrence.

	La sûreté découle de cette proposition.

\end{proof}

Pour les trois lemmes ci-dessous, on se fixe une exécution de l'algorithme.
On dit que le système est synchonisé au round $i$ si tous les processus actifs ont la même valeur de compteur dans $\mathds{Z}/k\mathds{Z}$.

\begin{lemma}
	Sous le prédicat $\mathcal{P}_{\xi-nek}$,
	si au round $i$, $\xi$ est actif et le système est synchonisé, il l'est également au round $i+1$.
\end{lemma}
\begin{proof}
	Si le système est synchronisé au round $i$, au round $i+1$, tous les processus enverront une même valeur $v$.
	Donc, pour tout $p \in \mathcal{A}_{i+1}$, on aura $M_p^{i+1}(\Pi) \subseteq \{v+1~mod~k, nil, \bot\}$.
	Le fait que $\xi$ est actif induit $v+1~mod~k \in M_p^{i+1}(\Pi)$.
	Donc la deuxième branche de la fonction de transition sera exécutée.
	La synchronisation est donc maintenue.
\end{proof}
\begin{lemma}
	Sous les prédicats $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$,
	si au round $i$, $\xi$ est actif et le système est synchonisé, tous les processus font feu.
\end{lemma}
\begin{proof}
	Le lemme précédent montre qu'à partir du round $i$, le système reste synchonisé. De plus, à chaque round, la valeur des compteurs est incrémentée.
	Soit $r$ le round à partir duquel tous les processus sont actifs.
	Ainsi, lors d'un round $i' \geq max(i, r)$, le système atteindra un état dans lequel tous les compteurs valent $k-1$.
	On aura alors, au round suivant, $\forall p \in \Pi, M_p^{i'}(\Pi) = \{0\}$.
	Donc tous les processus font feu.
\end{proof}

On montre maintenant la vivacité dans un cas simple.
Soit $\mathcal{P}_{star} \equiv \exists \xi \in \Pi, \forall p \in \Pi, \forall r \in \mathds{N}, HO(p, r) = \{\xi\}$

\begin{theorem}
	L'algorithme résout la synchronisation modulo $k$ lorsque les prédicats $\mathcal{P}_{star}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	$\xi$ s'active en temps fini d'après le prédicat $\mathcal{P}_{non-inf}$.
	Soit $r$ le round auquel $\xi$ s'active.
	Au round $r$, $\xi$ exécute nécessairement la troisième branche de la fonction de transition, donc $x_\xi(r) = k-1$.
	Ainsi, au round $r+1$, $\xi$ enverra 0 à tous, donc le système se synchronisera sur 0.
	Le lemme précédent montre la vivacité, et le lemme 1 la sûreté.
\end{proof}

On montre maintenant la vivacité dans le cas qui nous intéresse.

\begin{theorem}
	L'algorithme résout la synchronisation modulo $k$ lorsque les prédicats $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	$\xi$ s'active en temps fini d'après le prédicat $\mathcal{P}_{non-inf}$.
	Soit $r$ le round auquel $\xi$ s'active.
	L'algorithme est conçu de telle manière que chaque processus n'exécute la troisième branche de la fonction de transition qu'une seule fois.
	Donc il existe un round $r' \geq r$ à partir duquel plus aucun processus n'exécute cette troisième branche.

	\begin{description}

		\item[Cas 1 : ] $\xi$ a exécuté la troisième branche de la fonction de transition au cours d'un round $t \geq r$.

			Dans ce cas, au round $t+1$, $\xi$ envoie 0 à tous, donc tous les processus s'alignent sur ce 0. Le système est maintenant synchonisé. Le lemme précédent montre la vivacité.

		\item[Cas 2 : ] $\xi$ n'a jamais exécuté la troisième branche, et n'a pas exécuté la quatrième branche au delà du round $r'$.

			Dans ce cas, au delà du round $r'$, $\xi$ n'exécute que les deux premières branches. Un raisonnement similaire à la preuve du théorème 1 montre la vivacité.

		\item[Cas 3 : ] $\xi$ n'a jamais exécuté la troisième branche, mais a exécuté la quatrième branche au round $t \geq r'$.

			Ainsi, au round $t+1$, $\xi$ envoie 1 à tous. Comme $t \geq r'$, les processus ne peuvent exécuter que la deuxième et la quatrième branche.
			Les seules valeurs présentes dans le système à la fin du round $t+1$ sont donc 0 et 1.
			On distingue deux sous-cas possibles :

			\begin{description}

				\item[Sous-cas 3.1] $x_\xi(t+1) = 1$

					Dans ce cas, on montre par récurrence sur $i$ que
					$$\forall i \in \mathds{N}, x_\xi(t+i) = i~mod~k \wedge \forall p \in \mathcal{A}_{t+i}, x_p(t+i) \leq x_\xi(t+i)$$

					\textbf{Initialisation : } voir ci-dessus.

					\textbf{Hérédité : } Pour $i$ donné, on suppose que 
					$$x_\xi(t+i) = i~mod~k \wedge \forall p \in \mathcal{A}_{t+i}, x_p(t+i) \leq x_\xi(t+i)$$
					L'hypothèse de récurrence montre que les messages envoyés au round $t+i+1$ sont compris entre 1 et $i+1~mod~k$.
					Le processus $\xi$ reçoit toujours sa propre valeur, à savoir $i+1~mod~k$, mais n'en reçoit jamais d'autre, celà provoquerait l'exécution de la troisième branche.
					On a pourtant supposé que $\xi$ n'exécutait jamais cette branche. Cela prouve $x_\xi(t+i+1) = i+1~mod~k$.

					Les autres processus reçoivent au round $t+i+1$ des valeurs comprises entre 1 et $i+1~mod~k$, cela prouve $\forall p \in \mathcal{A}_{t+i}, x_p(t+i) \leq x_\xi(t+i)$.

					Cette récurrence montre qu'au round $t+k$, $\xi$ envoie 0 à tous, ce qui synchrones le système. Le lemme précédent assure la vivacité.

				\item[Sous-cas 3.2] $x_\xi(t+1) = 0$

					Dans ce cas, $\xi$ envoie 1 à tous les processus au round $t+i+1$. Les valeurs envoyées par les autres processus sont nécessairement 1 et 2.
					$\xi$ ne peut pas avoir reçu un 2, car on a supposé que $\xi$ n'a jamais exécuté la troisième branche. Donc la valeur de $\xi$ à la fin du round est nécessairement 1.
					Pour les autres processus, les seules valeurs possibles sont 0 et 1. On est donc ramené au cas précédent.
			\end{description}
	\end{description}

	Cette disjonction de cas achève donc la vivacité. La sûreté étant garantie par le lemme 1.
\end{proof}

Maintenant que la validité de l'algorithme SyncMod est établie, on peut affirmer le théorème suivant :

\begin{theorem}
	L'algorithme "Uniforme Voting" exécuté en série à la suite de l'algorithme "SyncMod" avec $k = 4$
	résout le consensus lorsque les prédicats $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\begin{proof}
	Le fait d'exécuter l'algorithme "Uniforme Voting" à la suite de SyncMod assure le fait que le calendrier d'activation de "Uniforme Voting" vérifie $\mathcal{P}_{sync-mod-4}$,
	donc à fortiori $\mathcal{P}_{sync-mod-2}$.
	La preuve de validité de "Uniforme Voting", précédamment présentée, s'applique donc.
\end{proof}

\section{Conclusion et extensions}

\subsection{Cas des graphes enracinés}

Maintenant que le cas $\mathcal{P}_{xi-nek}$ a été traité, on peut s'intéresser au cas, plus général, des graphes dynamiques vérifiant $\mathcal{P}_{T-rooted}$.



\printbibliography

\end{document}
