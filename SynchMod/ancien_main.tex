\documentclass[11pt,letterpaper]{article}
\special{papersize=8.5in,11in}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm,dsfont}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes.symbols,arrows}

\usetikzlibrary{shapes.symbols,arrows}
\usepackage{enumerate}

\DeclareMathOperator{\NC}{NC}
\DeclareMathOperator{\NCL}{NCL}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Rem}{Rem}
\DeclareMathOperator{\Simp}{Simp}
\DeclareMathOperator{\Crit}{Crit}
\DeclareMathOperator{\Extr}{Extr}
\DeclareMathOperator{\Closed}{Closed}
\DeclareMathOperator{\Cyc}{Closed}
\DeclareMathOperator{\Step}{Step}
\DeclareMathOperator{\Red}{Red}
\DeclareMathOperator{\Inc}{Inc}
\DeclareMathOperator{\Start}{Start}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Edges}{Edges}
\DeclareMathOperator{\Sections}{Sections}
\newcommand{\CDD}{{cd}}
\newcommand{\EP}{{ep}}
\newcommand{\CF}{{cr}}
\newcommand{\nc}{{\mathrm{ nc}}}
\newcommand{\In}{{\mathrm {In}}}
\newcommand{\legendre}[2]{\genfrac{(}{)}{}{}{#1}{#2}}
\newcommand{\cT}{{ (c,T)  }}
\newcommand{\tY}{\tilde{Y}}
\newcommand{\oY}{\overline{Y}}

\newcommand{\IR}{\mathds{R}}
\newcommand{\IN}{\mathds{N}}
\newcommand{\IZ}{\mathds{Z}}
\newcommand{\IQ}{\mathds{Q}}
\newcommand{\IC}{\mathds{C}}
\newcommand{\M}{\mathcal{M}}

\newcommand{\Bcnc}{A^{\Delta}_{\mathrm {c}}}
\newcommand{\Bunu}{\tilde{B}}
\newcommand{\Bms}{\tilde{B}}
\newcommand{\Bep}{A^{\Delta}_\mathrm{e}}
\newcommand{\Benp}{A^{\Delta}_\mathrm{e}}
\newcommand{\Bneone}{A^{\Delta}_\mathrm{r}}
\newcommand{\Bnetwo}{A^{\Delta}_\mathrm{r}^\mathrm{HA}}

\newcommand{\SCC}{\mathcal{C}}
\newcommand{\CP}{\mathcal{P}_\ccirclearrowleft}

\newcommand{\IRmax}{\overline{\IR}}
\newcommand{\IRmin}{{\IR}_{\min}}
\newcommand{\wstar}{{w}_{*}}
\newcommand{\ito}{{i\!\to}}
\newcommand{\Pa}{{\mathcal{W}}}

\newcommand{\real}[1]{\mathbf{N}_{\geqslant {#1}}}
\newcommand{\realrem}[2]{\mathbf{N}_{\geqslant {#1}}^{({#2})}}

\renewcommand{\le}{\leqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\geq}{\geqslant}

\newcommand{\one}{\mathds{1}}

\newcommand{\shlomo}[1]{\comment{\textcolor{red}{Shlomo: #1}}}
\newcommand{\be}[1]{\comment{\textcolor{blue}{b: #1}}}
\newcommand{\comment}[1]{\textcolor{red}{\textbf{#1}}}
\newcommand{\ignore}[1]{}


\newtheorem{thm}{Theorem}
\newtheorem{pro}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defi}[thm]{Definition}

\newcommand{\onevec}{{\mathbf{1}}}
\newcommand{\zerovec}{{\mathbf{0}}}

\usepackage[ruled, linesnumbered, noline]{algorithm2e}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}

\usepackage{biblatex}
\addbibresource{dynamic.bib}
\addbibresource{bibase.bib}

\newcommand{\cent}{\gamma}

\newcommand{\dG}{\mathds{G}}
\newcommand{\IN}{\mathds{N}}
\newcommand{\IS}{\mathds{S}}

\newcommand{\In}{\mathrm{In}}
\newcommand{\ts}{s}
\newcommand{\tf}{\phi}
\newcommand{\try}{\tau}
\newcommand{\SM}{{\em SynchMod}$_{\,k}\ $}

\title{Synchronization Modulo $k$ in Dynamic Networks}
\author{Bernadette Charron-Bost\textsuperscript{1} \and Louis Penet de Monterno\textsuperscript{1}}
\date{\textsuperscript{1} \'Ecole polytechnique, 91128 Palaiseau, France\\~\\ \today}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
	We define the mod k—synchronization problem as a weakening of the Firing Squad problem,
	where all nodes fire not at the same round, but at rounds that are all equal modulo k.
	We propose an algorithm that achieves mod k—synchronization  in any dynamic network
	with a fixed spanning star. As opposed to the perfect synchronization in
	the Firing Squad problem, mod k—synchronization thus does not require
	any strong connectivity property in the network. 
	Then, we develop our approach for the consensus problem,
	and present different consensus algorithms that all tolerate asynchronous starts.
\end{abstract}

% section_intro (do not modify this comment)
\section{Introduction}

% section_model (do not modify this comment)
\section{Preliminaries}\label{sec:model}

% section_algorithm (do not modify this comment)
\section{The \SM algorithm}

In this algorithm, the nodes hold a $level$ variable. When they start, they are level 0. They eventually reach level 1 then level 2.
A node fires when it reaches level 2.

Let $\mathds{G} = (\Pi, (E_r))$ be a dynamic graph and $\mathcal{A}$ an activation schedule.
We construct the dynamic graph $\mathds{G}_\mathcal{A} = (V, (E_r \setminus ((\Pi \setminus \mathcal{A}_r) \times \Pi)))$.
$\mathds{G}_\mathcal{A}$ is actually the dynamic graph $\mathds{G}$ where the incoming edges from any passive node have been removed.

Let $In_u(t:t')$ be the set of incoming neighbours of $u$ in the graph $\mathds{G}_\mathcal{A}(t:t')$.
$In_u(t:t')$ actually represents the set of nodes whose state in round $t$ is known by $u$ in round $t'$.
For any $i \in \{0, 1, 2, 3\}$, let $In_u^i(t:t')$ be the subset of $In_u(t:t')$ of nodes whose level is at least $i$ in round $t$.
We have $In_u^2(t:t') \subseteq In_u^1(t:t') \subseteq In_u^0(t:t') \subseteq In_u(t:t')$.

The colored section in the algorithm actually implement an optimization.
For the proof, we will at first consider this optimization disabled.

For convenience reason, the definition of slices (e.g. $\mathds{G}(t:t')$) excludes the lower bound (i.e. $\mathds{G}(t)$).

\begin{algorithm}[htb]
	\DontPrintSemicolon
	\textbf{Initialization:} \;
	\Indp
		$c_u \in \mathds{N}$, initially 0 \;
		$level_u \in \{0, 1, 2\}$, initially 0 \;
	\BlankLine
	\Indm
	\textbf{At each round $r$:} \;
	\Indp
		$let~i \leftarrow argmax_{i \in \{0, 1, 2\}}~\bigcup\limit_{h \in \mathds{N}} In_u^i(h:r) \neq \emptyset$ \;\label{line:argmax}
		$c_u \leftarrow argmin_{t \in \mathds{N}}~In_u^i(r-t:r) \nsubseteq In_u^i(r-t-1:r)$ \;\label{line:argmin} 
		\If{$In_u(r-k:r) = In_u^i(r-k:r)$ and all nodes in $In_u^i(r-k:r)$ have values congruent with 0}{ \label{line:levelup} 
			$level_u \leftarrow i+1$ \;
		}
		\If{$\color{teal} c_u \equiv 0 [k] \wedge In_u^2(0:r) \neq \emptyset$}{
			$\color{teal} level_u \leftarrow 2$ \;
		}
	\Indm
\caption{The generalized \SM algorithm} 
\end{algorithm}

\begin{lem} \label{lem:no-close-levelup}
	If $\cent$ reaches level 1 in round $t+k$, no node can level up in any round between $t+k+1$ and $t+2k-1$.
\end{lem}
\begin{proof}
	We assume that $u$ levels up in round $t+k+i$ where $i \in \{1, \dots, k-1\}$.
	Then no passive node may belong to $In_u(t+i:t+k+i)$.
	Using $\mathcal{P}_{delayed-star}$, we get that $\cent \in In_u(t+i:t+k+i)$.

	By assumption, $c_\cent(t+i) \equiv 0 [k]$. Let $h$ be the natural number such that $c_\cent(t+i) = h \times k$.
	We know that $c_\cent(t+i) \neq 0$, otherwise $\cent$ would be passive in round $t$, $\cent$ could not have leveled up in round $t+k$.
	Using line \ref{line:argmin}, we can obtain the node $v \in In_u^0(t-i-h\times k:t+i)$ such that $In_u^0(t+i-h\times k+1:t+i) = \emptyset$.
	There must exist a path of active nodes between $v$ and $u$ in the interval $[t+i-h\times k, t+i]$.
	We consider the node $w$ which is on this path in round $t$.
	Since $v \in In_w^0(t+i-h\times k:t)$ and $In_w^0(t+i-h\times k+1:t) \subseteq In_u^0(t+i-h\times k+1:t+i) = \emptyset$,
	the value of $w$ in round $t$ must be $h\times k - i$.
	Moreover, $w$ belongs to $In_\cent(t:t+k)$. From line \ref{line:levelup}, we get that the value of $w$ must be congruent to 0 in round $t$.
	We obtain a contradiction.
\end{proof}

\begin{lem} \label{lem:later-level}
	If $\cent$ reached level 1 in round $t$, whereas $u$ reached level 1 in round $t+i$, then $i \equiv 0 [k]$. 
\end{lem}
\begin{proof}
	By contradiction, we assume that there exists a node $u$ being the earliest node reaching level 1 in round $t+i$ with $i \not\equiv 0 [k]$.
	The case $i < k$ is impossible according to lemma \ref{lem:no-close-levelup}.
	Moreover, no passive node may belong to $In_u(t+i-k:t+i)$.
	Using $\mathcal{P}_{delayed-star}$, we get that $\cent \in In_u(t+i-k:t+i)$.
	We obtain $c_\cent(t+i-k) \equiv 0$.

	In round $t+i-k$, $\cent$ is the latest node reaching level 1. Moreover $\cent \in In_\cent(0:t+i-k)$.
	According to \ref{line:argmin} and \ref{line:argmax}, we have $c_\cent(t+i-k) = i-k$.
	Thus $i \equiv 0 [k]$. We get a contradiction.
\end{proof}

\begin{lem}
	The algorithm is safe.
\end{lem}
\begin{proof}
	Let $t$ be the round in which $\cent$ reaches level 1.
	According to line \ref{line:levelup} and lemma \ref{lem:no-close-levelup}, no node may reach level 2 before round $t+k$.

	Moreover, from lemma \ref{lem:later-level}, we obtain $c_\cent(t+i) \equiv 0 [k] \Rightarrow i \equiv 0 [k]$.
	Then, if $u$ reaches level 2 in round $t+j$, it would mean that $\cent \in In_u(t+j-k:t+j)$ and $c_\cent(t+j-k) \equiv 0 [k]$.
	We obtain $j \equiv 0 [k]$. That proves safety.
\end{proof}

\begin{lem}
	The \texcolor{teal}{optimized} algorithm is live.
\end{lem}
\begin{proof}
	For any node $u$, the sequence $(In_u(t:\infty))_{t \in \mathds{N}}$ is decreasing.
	We note $In_u(\intfy)$ its limit ($v \in In_u(\infty)$ means that $u$ infinitely often hears from $v$).

	The collection $(In_u(\infty))_{u \in \Pi}$ may be interpreted as a graph $G_\infty = (V, \{(u,v), u \in In_v(\infty)\})$.
	We consider a source of the condensation graph of $G_\infty$.
	This source is a subset $S \subseteq \Pi$ which forms a clique in $\Pi$, and eventually never receive any message from the outside.
	Then, for every nodes in $S$, for every $t$, the sets $In_u^0(t:t')$ must converge to $\bigcup\limits_{v \in S} In_v(0:\infty)$ when $t'$ grows to infinity.

	When, at a given $t'$, every node $u \in S$ has reached $In_u(0:t') = \bigcup\limits_{v \in S} In_v(0:\infty)$, the nodes hold mutually identical sets $In_v^0(t:t')$.
	From this point, the nodes in $S$ must hold congruent values.
	They must reach level before round $t'+2k$, and level 2 before round $t'+3k$.

	Finally, every node $u \in \Pi$ will eventually hear from a source node.
	Moreover, the sequence $(In_u(0:t))_{t \in \mathds{N}}$ is increasing and eventually stabilizes.
	After this point, $c_u(t+1) = c_u(t)+1$.
	Thus, $u$ will eventually reach $c_u(t) \equiv 0 [k] \wedge In_u^3(0:t) \neq \emptyset$.
	That proves liveness.
\end{proof}

% section_cons (do not modify this comment)
\section{Use-cases of $\mathrm{mod}\,n$-synchronization}

% section_conclusion (do not modify this comment)
\section{Conclusion and future work}

% end_section (do not modify this comment)

\printbibliography

\end{document}
