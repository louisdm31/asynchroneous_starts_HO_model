\documentclass[11pt,letterpaper]{article}
\special{papersize=8.5in,11in}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm,dsfont}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{shapes.symbols,arrows}

\usetikzlibrary{shapes.symbols,arrows}
\usepackage{enumerate}

\usepackage{algorithm,algorithmic}

\renewcommand{\algorithmicrequire}{\textbf{Initialization:}}
\renewcommand{\algorithmicensure}{\textbf{In each round $t$ do:}}

\newcommand{\INITIALLY}{\REQUIRE{}}
\newcommand{\ROUND}{\ENSURE{}}


\DeclareMathOperator{\NC}{NC}
\DeclareMathOperator{\NCL}{NCL}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Rem}{Rem}
\DeclareMathOperator{\Simp}{Simp}
\DeclareMathOperator{\Crit}{Crit}
\DeclareMathOperator{\Extr}{Extr}
\DeclareMathOperator{\Closed}{Closed}
\DeclareMathOperator{\Cyc}{Closed}
\DeclareMathOperator{\Step}{Step}
\DeclareMathOperator{\Red}{Red}
\DeclareMathOperator{\Inc}{Inc}
\DeclareMathOperator{\Start}{Start}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Edges}{Edges}
\DeclareMathOperator{\Sections}{Sections}
\newcommand{\CDD}{{cd}}
\newcommand{\EP}{{ep}}
\newcommand{\CF}{{cr}}
\newcommand{\nc}{{\mathrm{ nc}}}
\newcommand{\In}{{\mathrm {In}}}
\newcommand{\legendre}[2]{\genfrac{(}{)}{}{}{#1}{#2}}
\newcommand{\cT}{{ (c,T)  }}
\newcommand{\tY}{\tilde{Y}}
\newcommand{\oY}{\overline{Y}}

\newcommand{\IR}{\mathds{R}}
\newcommand{\IN}{\mathds{N}}
\newcommand{\IZ}{\mathds{Z}}
\newcommand{\IQ}{\mathds{Q}}
\newcommand{\IC}{\mathds{C}}
\newcommand{\M}{\mathcal{M}}

\newcommand{\Bcnc}{A^{\Delta}_{\mathrm {c}}}
\newcommand{\Bunu}{\tilde{B}}
\newcommand{\Bms}{\tilde{B}}
\newcommand{\Bep}{A^{\Delta}_\mathrm{e}}
\newcommand{\Benp}{A^{\Delta}_\mathrm{e}}
\newcommand{\Bneone}{A^{\Delta}_\mathrm{r}}
\newcommand{\Bnetwo}{A^{\Delta}_\mathrm{r}^\mathrm{HA}}

\newcommand{\SCC}{\mathcal{C}}
\newcommand{\CP}{\mathcal{P}_\ccirclearrowleft}

\newcommand{\IRmax}{\overline{\IR}}
\newcommand{\IRmin}{{\IR}_{\min}}
\newcommand{\wstar}{{w}_{*}}
\newcommand{\ito}{{i\!\to}}
\newcommand{\Pa}{{\mathcal{W}}}

\newcommand{\real}[1]{\mathbf{N}_{\geqslant {#1}}}
\newcommand{\realrem}[2]{\mathbf{N}_{\geqslant {#1}}^{({#2})}}

\renewcommand{\le}{\leqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\geq}{\geqslant}

\newcommand{\one}{\mathds{1}}

\newcommand{\shlomo}[1]{\comment{\textcolor{red}{Shlomo: #1}}}
\newcommand{\be}[1]{\comment{\textcolor{blue}{b: #1}}}
\newcommand{\comment}[1]{\textcolor{red}{\textbf{#1}}}
\newcommand{\ignore}[1]{}


\newtheorem{thm}{Theorem}
\newtheorem{pro}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defi}[thm]{Definition}

\newcommand{\onevec}{{\mathbf{1}}}
\newcommand{\zerovec}{{\mathbf{0}}}

\usepackage[noend]{libHO/distribalgo}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}

\usepackage{biblatex}
\addbibresource{dynamic.bib}
\addbibresource{bibase.bib}

\newcommand{\cent}{\gamma}

\newcommand{\dG}{\mathds{G}}
\newcommand{\IN}{\mathds{N}}
\newcommand{\IS}{\mathds{S}}

\newcommand{\In}{\mathrm{In}}
\newcommand{\ts}{s}
\newcommand{\tf}{\phi}
\newcommand{\try}{\tau}
\newcommand{\SM}{{\em SynchMod}$_{\,k}\ $}

\title{Synchronization Modulo $k$ in Dynamic Networks}
\author{Bernadette Charron-Bost\textsuperscript{1} \and Louis Penet de Monterno\textsuperscript{1}}
\date{\textsuperscript{1} \'Ecole polytechnique, 91128 Palaiseau, France\\~\\ \today}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
	We define the mod k—synchronization problem as a weakening of the Firing Squad problem,
	where all nodes fire not at the same round, but at rounds that are all equal modulo k.
	We propose an algorithm that achieves mod k—synchronization  in any dynamic network
	with a fixed spanning star. As opposed to the perfect synchronization in
	the Firing Squad problem, mod k—synchronization thus does not require
	any strong connectivity property in the network. 
	Then, we develop our approach for the consensus problem,
	and present different consensus algorithms that all tolerate asynchronous starts.
\end{abstract}

% section_intro (do not modify this comment)
\section{Introduction}

% section_model (do not modify this comment)
\section{Preliminaries}\label{sec:model}

% section_algorithm (do not modify this comment)
\section{The \SM algorithm}

The colored section in the algorithm actually implement an optimization.
For the proof, we will at first consider this optimization disabled.

\subsection{The GeneralizedSynchMod algorithm}

\begin{algorithm}[htb]\label{algo:code}
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
	\STATE $c_u \in \mathds{N}$, initially 0
	\STATE $concordant_u \leftarrow false$
	\STATE $ready_u \leftarrow false$
	\STATE $force_u \in \{0, 1, 2\}$, initially 0
	\STATE $level_u \in \{0, 1, 2\}$, initially 0

\ENDINDENT \BLANK

\INDENT{\textbf{In each round $t$:}}
	\STATE send $\langle \overline{c}_u, concordant_u, force_u, ready_u \rangle$ to all 
	\STATE receive incoming messages
	\STATE $force_u \leftarrow$ maximum forcing level received \label{line:force}
	\STATE $c_u \leftarrow 1+$ minimum received value among maximum force messages \label{line:min-z-end}
	\STATE $ready_u \leftarrow$ all received messages were tagged as ready \label{line:ready-gossip} 
	\STATE $concordant_u \leftarrow$ all received values are congruent modulo $k$ and no null received \label{line:conc-gossip}
	\IF{$c_u \equiv 0 [k] \wedge (concordant_u \textcolor{teal}{\vee force_u = 2)}$} \label{line:cond-levelup} 
		\IF{$level_u = 0$}
			\STATE $level_u \leftarrow 1$
			\STATE $force_u \leftarrow 1$ \label{line:force2}
			\STATE $c_u \leftarrow 0$ \label{line:force3}
		\ENDIF
		\IF{$\textcolor{teal}{force_u = 2 \vee} ready_u$} \label{line:cond-firing} 
			\STATE $\color{teal} force_u \leftarrow 2$
			\STATE $level_u \leftarrow 2$
		\ENDIF
		\STATE $concordant_u \leftarrow true$ \label{line:conc-true}
		\STATE $ready_u \leftarrow level_u > 0$ \label{line:init-ready}
	\ENDIF
\ENDINDENT 

\caption{The generalized \SM algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

We assume that the dynamic graph verifies the predicate $\mathcal{P}_{rooted} \equiv \exists \cent \in \Pi, \exists D > 0, \mathds{G}(t:t+D)$ contains a spanning tree rooted by $\cent$.
We also assume that $2D+1 < k$.

\begin{lem} \label{lem:conc-safety}
	If $concordant_u(t+k) \wedge c_u(t+k) \equiv 0 [k]$, then, for all $i \in \{0, \dots, k/2\}$, the counter of $\cent$ verifies $c_\cent(t+i) \equiv i [k]$.
\end{lem}
\begin{proof}
	We have $t+k - (t+i) \geq k - k/2 \geq k/2 \geq D$.
	Then, using $\mathcal{P}_{rooted}$, for any $i \in \{1, \dots, k/2\}$ in the above range, there exists a path $(\cent = v(i), \dots, v(k) = u)$ from $\cent$ in round $t+i$ to $u$ in round $t+k$. 
	We can now show using a backward induction on this path that every node $v(j)$ on this path is active and verifies $c_{v(j)}(t+j) \equiv j [k]$ and $concordant_{v(j)}(t+j)$.

	The base case is the hypothesis of the lemma.
	For the induction case, we assume that $i \leq j < k$, and $\overline{c}_c(j+1)(t+j) \equiv j [k]$ and $concordant_c(j)(t+j)$.
	By the definition of a path, we know that $c(j)$ sent a message $\langle v, concordant_c(j)(t+j), *, * \rangle$ to $c(j+1)$.
	If $i = j = 1$, the induction case is deductible from line \ref{line:conc-true}.
	Otherwise, from line \ref{line:conc-gossip}, we get that $c(j)$ is active and $concordant_{c(j)}(t+j)$. Moreover, the received messages are concordant.
	Then, from line \label{line:min-z-end}, we get $\overline{c}_c(j+1)(t+j+1) \equiv v+1 [k]$, then $\overline{c}_c(j)(t+j) \equiv v \equiv j [k]$.
\end{proof}

Using the exact same reasoning, we can prove the following lemma.
\begin{lem} \label{lem:conc-safety-bis}
	If $concordant_u(t+k) \wedge ready_u(t+k) \wedge c_u(t+k) \equiv 0 [k]$, then $\cent$ must already have reached level 1 in round $t+i$.
\end{lem}
\begin{proof}
	We consider a path $(\cent = v(0), \dots, v(k) = u)$.
	We can show using a backward induction on this path that any node on this path is active and verifies $concordant_{v(i)} \wedge ready_{v(i)}$.
	That proves the lemma.
\end{proof}

\begin{lem} \label{lem:no-close-level2}
	If $u$ reaches level 1 in round $t+k$, no node can level up in any round between $t+k+1$ and $t+k+k/2$.
\end{lem}
\begin{proof}
	We assume that $v$ levels up in round $t+k+i$ where $i \in \{1, \dots, k/2\}$.
	Applying the lemma \ref{lem:conc-safety} to $u$ and $v$, we get respectively $c_\cent(t+i) = i$ and $c_\cent(t+i) = 0$.
	That contradicts the assumption $i > 0$.
\end{proof}

\begin{lem} \label{lem:ready-safety}
	If node $u$ reaches level 2 in round $t+i$, then $\cent$ must have reached level 1 in a previous round $t$. Moreover $c_u(t+i) \leq i$.
\end{lem}
\begin{peoof}
	The first part of the lemma results from lemma \ref{lem:conc-safety-bis}. We now prove the second part.
	We consider a path $(\cent = v(0), \dots, v(i) = u)$ from $\cent$ in round $t$ to $u$ in round $t+k$. This path must exist, since lemma \ref{lem:no-close-level2} tells us that $i > k/2$.
	Using a simple backward induction on this path, we can show that any $v(j)$ on this path is active, is at least in level 1, and verifies $ready_{v(j)}(t+j)$ and $concordant_{v(j)}(t+j)$.
	The base case relies on the lines \ref{line:cond-firing} and \ref{line:cond-levelup}. The induction case relies on lines \label{line:ready-gossip} and \ref{line:ready-gossip}.

	Using a simple forward induction on this path, we can show that any $v(j)$ on this path verifies $force_{v(j)}(t+j) \geq 1$ and $c_{v(j)}(t+j) \leq j$.
	The base case relies on the lines \ref{line:force2} and \ref{line:force3}. The induction case relies on lines \label{line:force} and \ref{line:min-z-end}.
\end{peoof}

\begin{lem} \label{lem:safety-force}
	If $c_u(t+i) = i$, then a node must have reached level $force_u(t+i)$ in round $t$.
\end{lem}
\begin{proof}
	Without loss of generality, we assume $force_u(t+i) = 1$.
	We show this lemma by induction over $i$.
	For the base case, we have to show that the line \ref{line:force2} was executed by $u$ in round $t$.
	This must be true, otherwise the fact that $c_u(t) = 0$ could not be explained.

	For the induction case, we assume that $c_u(t+i+1) = i+1$ and $force_u(t+i+1) = 1$.
	Then, a node $v$ must have sent a message which looks like $\langle i, *, 1, * \rangle$ (see lines \ref{line:force} and \ref{line:min-z-end}).
	The proof can now be concluded thanks to the induction hypothesis.
\end{proof}

\begin{lem} \label{lem:later-level1}
	If $\cent$ reached level 1 in round $t$, whereas $u$ reached level 1 in round $t+i$, then $i \equiv 0 [k]$. 
\end{lem}
\begin{proof}
	By contradiction, we consider the first node $u$ which reaches level 1 in round $t+i$ with $i \not\equiv 0 [k]$.
	The case $i \leq k/2$ is impossible according to lemma \ref{lem:no-close-level2}.

	In the case $i > k/2$, since $concordant_u(t+i)$ is true, there exist an active path from $\cent$ in round $t$ to $u$ in round $t+i$.
	On this path $(v(0), \dots, v(i))$, we can show by a simple induction that, for any $0 \leq j \leq i$, we have $c_{v(j)}(t+j) \leq c_\cent(t)+j$.
	Since we assumed that $i \not\equiv 0[k]$, we have $c_u(t+i) \neq c_\cent(t)+i$.
	Then, using lemma \ref{lem:safety-force} gives us that a node $v$ must have reached level 1 later than $\cent$, with $c_v(t+i) = c_u(t+i)$.
	This contradicts the fact that $u$ was the first non-congruent level 1 node.
\end{proof}

\begin{thm} \label{lem:safety} 
	The algorithm is safe.
\end{thm}
\begin{proof}
	We assume that $u$ and $v$ reach level 2 in round $t+i$ and $t+j$ respectively.
	According to lemma \ref{lem:ready-safety}, $\cent$ must have reached level 1 in a previous round $t$.
	Moreover $c_u(t+i) \leq i$ and $c_v(t+j) \leq j$.
	According to lemma \ref{lem:safety-force}, there must exist nodes $w$ and $w'$ which reached level 1 in rounds $t+i-c_u(t+i)$ and $t+j-c_u(t+j)$ respectively.
	According to lemma \ref{lem:later-level1}, we have $i-c_u(t+i) \equiv 0 [k]$ and $j-c_u(t+j) \equiv 0 [k]$. 
	Since we have $c_u(t+i) \equiv 0 [k]$ and $c_v(t+j) \equiv 0 [k]$, we get $i \equiv j [k]$. That proves safety.
\end{proof}

\begin{lemma}
	Every node reaches level 1.
\end{lemma}
\begin{proof}
	Let $Z_r$ be the set of level 0 nodes in round $r$.
	Let $V_r$ be the set of values of $Z_r$.
	We consider the sequence $h_r = |Z_r| + max V_r - min V_r$.
	We have to show that $Z_r$ eventually becomes empty, in other words $(h_r)$ is eventually undefined.
	By contradiction, we assume that $(h_r)$ is always defined.
	Let $s^{max}$ the first round in which every node is active.
	If $r \geq s^{max}$, we can show that if $V_r \subseteq \{t, \dots, t+i\}$, then $V_{r+1} \subseteq \{t+1, \dots , t+i+1\}$ (see line \ref{line:min-z-end}).
	That proves that $(h_r)$ cannot grow from $s^{max}$.
	Then, from a round $t$, the set $Z_r$ is stabilized and $max V_r - min V_r$ is constant.
	We consider the set $Z_r^{max}$, which contains every nodes $u$ such that $c_u(r) = max V_r$.
	For any $r \geq t$, we can show that $Z_{r+1}^{max} = \{u \in Z_r^{max}, HO(u, r+1) \subseteq Z_r^{max}\}$. That is a consequence of line \ref{line:min-z-end}.
	Then, this sequence of set is decreasing from $t$. Moreover, it cannot become empty. Then we consider the non-empty set $M = \bigcap\limits_{r \geq t} Z_r^{max}$.
	Such a set is a subset of the system, which from $t$, never receive any message from the outside, and all hold the same value.
	From the round $t+k$, the line \ref{line:conc-gossip} implies that any $u \in M$ must verify $\forall r > t+k, concordant_u(r)$.
	Then, every node in $M$ must reach level 1 before round $t+2k$.
	However we assumed that $Z_r$ was constant from $t$. We get a contradiction.
\end{proof}

\begin{lem}
	The algorithm is live
\end{lem}
\begin{proof}
	We consider the round $t$ in which every node have reached level 1.
\end{proof}

% section_cons (do not modify this comment)
\section{Use-cases of $\mathrm{mod}\,n$-synchronization}

% section_conclusion (do not modify this comment)
\section{Conclusion and future work}

% end_section (do not modify this comment)

\printbibliography

\end{document}
