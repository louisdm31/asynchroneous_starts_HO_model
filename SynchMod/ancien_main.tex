\documentclass[11pt,letterpaper]{article}
\special{papersize=8.5in,11in}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm,dsfont}
\usepackage{tikz}
\usetikzlibrary{shapes.symbols,arrows}

\usetikzlibrary{shapes.symbols,arrows}
\usepackage{enumerate}

\usepackage{algorithm,algorithmic}

\renewcommand{\algorithmicrequire}{\textbf{Initialization:}}
\renewcommand{\algorithmicensure}{\textbf{In each round $t$ do:}}

\newcommand{\INITIALLY}{\REQUIRE{}}
\newcommand{\ROUND}{\ENSURE{}}


\DeclareMathOperator{\NC}{NC}
\DeclareMathOperator{\NCL}{NCL}
\DeclareMathOperator{\lcm}{lcm}
\DeclareMathOperator{\Rem}{Rem}
\DeclareMathOperator{\Simp}{Simp}
\DeclareMathOperator{\Crit}{Crit}
\DeclareMathOperator{\Extr}{Extr}
\DeclareMathOperator{\Closed}{Closed}
\DeclareMathOperator{\Cyc}{Closed}
\DeclareMathOperator{\Step}{Step}
\DeclareMathOperator{\Red}{Red}
\DeclareMathOperator{\Inc}{Inc}
\DeclareMathOperator{\Start}{Start}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Edges}{Edges}
\DeclareMathOperator{\Sections}{Sections}
\newcommand{\CDD}{{cd}}
\newcommand{\EP}{{ep}}
\newcommand{\CF}{{cr}}
\newcommand{\nc}{{\mathrm{ nc}}}
\newcommand{\In}{{\mathrm {In}}}
\newcommand{\legendre}[2]{\genfrac{(}{)}{}{}{#1}{#2}}
\newcommand{\cT}{{ (c,T)  }}
\newcommand{\tY}{\tilde{Y}}
\newcommand{\oY}{\overline{Y}}

\newcommand{\IR}{\mathds{R}}
\newcommand{\IN}{\mathds{N}}
\newcommand{\IZ}{\mathds{Z}}
\newcommand{\IQ}{\mathds{Q}}
\newcommand{\IC}{\mathds{C}}
\newcommand{\M}{\mathcal{M}}

\newcommand{\Bcnc}{A^{\Delta}_{\mathrm {c}}}
\newcommand{\Bunu}{\tilde{B}}
\newcommand{\Bms}{\tilde{B}}
\newcommand{\Bep}{A^{\Delta}_\mathrm{e}}
\newcommand{\Benp}{A^{\Delta}_\mathrm{e}}
\newcommand{\Bneone}{A^{\Delta}_\mathrm{r}}
\newcommand{\Bnetwo}{A^{\Delta}_\mathrm{r}^\mathrm{HA}}

\newcommand{\SCC}{\mathcal{C}}
\newcommand{\CP}{\mathcal{P}_\ccirclearrowleft}

\newcommand{\IRmax}{\overline{\IR}}
\newcommand{\IRmin}{{\IR}_{\min}}
\newcommand{\wstar}{{w}_{*}}
\newcommand{\ito}{{i\!\to}}
\newcommand{\Pa}{{\mathcal{W}}}

\newcommand{\real}[1]{\mathbf{N}_{\geqslant {#1}}}
\newcommand{\realrem}[2]{\mathbf{N}_{\geqslant {#1}}^{({#2})}}

\renewcommand{\le}{\leqslant}
\renewcommand{\leq}{\leqslant}
\renewcommand{\ge}{\geqslant}
\renewcommand{\geq}{\geqslant}

\newcommand{\one}{\mathds{1}}

\newcommand{\shlomo}[1]{\comment{\textcolor{red}{Shlomo: #1}}}
\newcommand{\be}[1]{\comment{\textcolor{blue}{b: #1}}}
\newcommand{\comment}[1]{\textcolor{red}{\textbf{#1}}}
\newcommand{\ignore}[1]{}


\newtheorem{thm}{Theorem}
\newtheorem{pro}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defi}[thm]{Definition}

\newcommand{\onevec}{{\mathbf{1}}}
\newcommand{\zerovec}{{\mathbf{0}}}

\usepackage[noend]{libHO/distribalgo}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}

\usepackage{biblatex}
\addbibresource{dynamic.bib}
\addbibresource{bibase.bib}

\newcommand{\cent}{\gamma}

\newcommand{\dG}{\mathds{G}}
\newcommand{\IN}{\mathds{N}}
\newcommand{\IS}{\mathds{S}}

\newcommand{\In}{\mathrm{In}}
\newcommand{\ts}{s}
\newcommand{\tf}{\phi}
\newcommand{\try}{\tau}
\newcommand{\SM}{{\em SynchMod}$_{\,k}\ $}

\title{Synchronization Modulo $k$ in Dynamic Networks}
\author{Bernadette Charron-Bost\textsuperscript{1} \and Louis Penet de Monterno\textsuperscript{1}}
\date{\textsuperscript{1} \'Ecole polytechnique, 91128 Palaiseau, France\\~\\ \today}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
	We define the mod k—synchronization problem as a weakening of the Firing Squad problem,
	where all nodes fire not at the same round, but at rounds that are all equal modulo k.
	We propose an algorithm that achieves mod k—synchronization  in any dynamic network
	with a fixed spanning star. As opposed to the perfect synchronization in
	the Firing Squad problem, mod k—synchronization thus does not require
	any strong connectivity property in the network. 
	Then, we develop our approach for the consensus problem,
	and present different consensus algorithms that all tolerate asynchronous starts.
\end{abstract}

% section_intro (do not modify this comment)
\section{Introduction}

% section_model (do not modify this comment)
\section{Preliminaries}\label{sec:model}

% section_algorithm (do not modify this comment)
\section{The \SM algorithm}

\subsection{The GeneralizedSynchMod algorithm}

\begin{algorithm}[htb]\label{algo:code}
\begin{distribalgo}[1]
\BLANK \INDENT{\textbf{Initialization:}}
	\STATE $\overline{c}_u \in \mathds{Z}/k\mathds{Z} \cup \{\bot\}$, initially $\bot$
	\STATE $concordant_u \leftarrow false$
	\STATE $ready_u \leftarrow false$
	\STATE $force_u \in \{0, 1, 2, 3\}$, initially 0
	\STATE $level_u \in \{0, 1, 2, 3\}$, initially 0
	\STATE $alarm_u \in \mathds{N} \cup \bot$, initially $\bot$

\ENDINDENT \BLANK

\INDENT{\textbf{In each round $t$:}}
	\STATE send $\langle \overline{c}_u, concordant_u, force_u, ready_u \rangle$ to all 
	\STATE receive incoming messages
	\IF{$\overline{c}_u = \bot$}
		\STATE $c_u = v$ where $v$ is the value of any received message, 0 if none received
	\ENDIF
	\STATE $force_u \leftarrow$ max forcing level received
	\IF{$level_u = 0 \wedge force_u = 0$}
		\STATE $\overline{c}_u \leftarrow \overline{c}_u+1$
	\ELSE
		\STATE $let~V = \{v, such~that~message~\langle v, *, force_u, * \rangle~received\}$
		\STATE $let~width(v) =$ smallest $i > 0$ such that $V \subseteq \{v, \dots, v+i\}$
		\STATE $\overline{c}_u \leftarrow argmin~width$
	\ENDIF
	\IF{$\overline{c}_u > k/2 \wedge force_u < 3$}
		\STATE $force_u \leftarrow 0$
	\ENDIF
	\STATE $ready_u \leftarrow$ all received messages were tagged as ready
	\STATE $concordant_u \leftarrow$ all received values are equal to $\langle v, true, *, * \rangle$ (hence no null, no $\bot$) \label{line:conc_gossip}
	\IF{$\overline{c}_u = 1$}
		\IF{$level_u = 0$}
			\STATE $force_u \leftarrow 1$
			\STATE $level_u \leftarrow 1$
		\ENDIF
		\IF{$concordant_u \wedge level_u = 1$}
			\STATE $level_u \leftarrow 2$
			\STATE $force_u \leftarrow 2$
		\ENDIF
		\IF{$force_u = 3 \vee (concordant_u \wedge ready_u)$}
			\STATE $force_u \leftarrow 3$
			\STATE $level_u \leftarrow 3$
		\ENDIF
		\STATE $concordant_u \leftarrow true$
		\STATE $ready_u \leftarrow level_u > 1$
	\ENDIF
\ENDINDENT 

\caption{The generalized \SM algorithm} \label{algo:R}
\end{distribalgo}

\end{algorithm}

\begin{lemma}
	If $concordant_u(t+k+1) \wedge \overline{c}_u(t+k+1) = 1$, then, for all $0 < i \leq k/2$, the counter of $\cent$ verifies $\overline{c}_\cent(t+i) = i$.
\end{lemma}
\begin{proof}
	For any $i$ in the above range, there exists a path from $\cent$ in round $t+i$ to $u$ in round $t+k+1$. 
	We can now show by induction over $k+1-i$ that for any $i < j < k+1$, the $j^{th}$-node $v(j)$ on this path verifies $c_v(j)(t+j) = j+1$ and $concordant_v(j)(t+j)$.
\end{proof}

\begin{lemma}
	If $u$ reaches level 2 in round $t+k+1$, no node can reach level 2 in any round between $t+k+2$ and $t+k+k/2+1$.
\end{lemma}
\begin{proof}
	By contradiction, we assume that $v$ reaches level 2 in round $t+k+2 < t+k+2+i \leq t+k+k/2$.
	Using previous lemma, we get $c_\cent(t+i) = i$ and $c_\cent(t+i) = 1$.
\end{proof}


\begin{lemma}
	If $concordant_u(r)$ is true, and $\overline{c}_u(r) = i > k/2$, then, $\forall h \in [r-i, r-D], \overline{c}_\cent(h) = h-r-i$
\end{lemma}

\begin{thm}
	The algorithm is safe.
\end{thm}
\begin{proof}
	We assume that $u$ is the first firing node, in round $r$.
	Then, $concordant_u(r)$ is true.
\end{proof}

% section_cons (do not modify this comment)
\section{Use-cases of $\mathrm{mod}\,n$-synchronization}

% section_conclusion (do not modify this comment)
\section{Conclusion and future work}

% end_section (do not modify this comment)

\printbibliography

\end{document}
