\documentclass[11pt,letterpaper]{article}
\special{papersize=8.5in,11in}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm,dsfont}
\usepackage{xcolor}
\usepackage{float}
\usepackage{tikz}
\usepackage{import}
\usetikzlibrary{shapes.symbols,arrows}

\usetikzlibrary{shapes.symbols,arrows}
\usepackage{enumerate}

\newtheorem{thm}{Theorem}
\newtheorem{pro}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defi}[thm]{Definition}

\usepackage[ruled, linesnumbered, noline]{algorithm2e}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[utf8]{inputenc}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}

\usepackage{biblatex}
\addbibresource{dynamic.bib}
\addbibresource{bibase.bib}

\newcommand{\cent}{\gamma}

\newcommand{\ts}{s}
\newcommand{\tf}{\phi}
\newcommand{\try}{\tau}

\title{Synchronization Modulo $k$ in Dynamic Networks}
\author{
	Bernadette Charron-Bost \\
	LIX, Palaiseau, France
\and
	Stephan Merz \\
	LORIA, Nancy, France
\and
	Louis Penet de Monterno \\
	LIX, Palaiseau, France
}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
	We define the mod k—synchronization problem as a weakening of the Firing Squad problem,
	where all nodes fire not at the same round, but at rounds that are all equal modulo k.
	We propose an algorithm that achieves mod k—synchronization  in any dynamic network
	with a fixed spanning star. As opposed to the perfect synchronization in
	the Firing Squad problem, mod k—synchronization thus does not require
	any strong connectivity property in the network. 
	Then, we develop our approach for the consensus problem,
	and present different consensus algorithms that all tolerate asynchronous starts.
\end{abstract}

% section_intro (do not modify this comment)
\section{Introduction}

Distributed algorithms are often designed in a synchronous computing model, in which computation
	is divided into communication {\em closed rounds}:
	any message  sent at some round  can be received only at that round.
In this model it is classically assumed that each run of an algorithm is started by all nodes simultaneously, i.e., at the same round,
	or even at round one.
For instance, most of synchronous consensus algorithms
	(e.g.,~\cite{PSL80,DS83,ST87}), as well as many distributed algorithms for dynamic networks (e.g.,~\cite{KLO10,KMO11})
	require synchronous starts.

This assumption makes the sequential composition of two distributed algorithms $A;B$
	-- in which each node starts executing $B$ when it has completed the execution of~$A$ --
	quite problematic.
Indeed, nodes start the algorithm~$B$ asynchronously when the algorithm~$A$ terminates asynchronously,
	and the properties of~$B$ are no more guaranteed in this context of asynchronous starts.

This leads to the problem of simulating synchronous starts, classically referred to as
	the {\em firing squad problem}:
Each node is  initially  {\em passive} and then become {\em active}  at an unpredictable round.
The goal is to guarantee that   the nodes, when all active, eventually synchronize
	by {\em firing} -- i.e., entering a designated state for the first time -- at the same round.

Unfortunately, the impossibility result in~\cite{CBM18} demonstrates that the firing squad problem
	is not solvable without a strong connectivity property of the network, namely, there exists  some positive
	integer~$T$ such that communication graph within  every period of $T$ consecutive
	rounds is strongly connected and the delay~$T$ is known.
In many situations,  this connectivity property is not guaranteed:
	as an example, in the dynamic graphs corresponding to any system model with benign failures,
	a node  that experiments permanent and complete send omissions
	is  constantly a sink in the  communication graph.

However, with a closer look at many distributed algorithms designed in the round-based model,  we see that
	these algorithms actually  do not require perfect synchronous starts, and still work under the weaker condition that all the nodes
	start executing the algorithms in rounds with numbers that are equal modulo~$k$, for some positive integer~$k$.
The corresponding synchronization problem, that we call $mod-k$  \emph{synchronization}, is formally specified as follows:
	\begin{description}
	\item[Termination:]   If all nodes are eventually active, then  every node eventually fires.
	\item[ $\mathbf{mod-k}$-simultaneity:]  If two nodes fire at round~$t$ and $t'$, then $t' \equiv t \mod k$.
	\end{description}

Indeed, let $A$ be an algorithm  organized into regular  \emph{phases} consisting of  a fixed number  $k$ of consecutive rounds:
	the sending and transition functions of every node at round~$t$ are entirely determined by the value of~$t$ modulo~$k$.
Moreover, assume that $A$ has been proved correct (with respect to some given specification) when all nodes start $A$
	synchronously (at round one) and with any dynamic graph in a family~${\cal G}$ that is stable  under
	addition of arbitrary finite prefixes.
For instance, the \emph{ThreePhaseCommit} algorithm for non-blocking atomic commitment~\cite{BHG87},
	as well as the consensus algorithms in~\cite{DLS88} or the \emph{LastVoting} algorithm ~\cite{CBS09}
	-- corresponding to the consensus core of \emph{Paxos} -- fulfill all the above requirements
	for phases of length $k=3$ and $k=4$, respectively, and the family ${\cal G}$ of dynamic graphs in which
	there exists an infinite number of ``good'' communication patterns
	(eg., a sequence of $2k-1$ consecutive communication graphs  in which a majority of nodes is heard by all
	in   each graph).
The use of a $mod-k$-synchronization algorithm on the top of the algorithm $A$ yields a new algorithm that executes
	exactly like $A$ does, after a finite preliminary period during which every node becomes active and fires.
The above property on the set of dynamic graphs ${\cal G}$ then guarantees this variant of $A$ to be correct with
	asynchronous starts and dynamic graphs in ${\cal G}$.

Another typical example for which perfect synchronization can be weakening into synchronization modulo $k$ is
	the development of the basic \emph{rotating coordinator} strategy in the context of asynchronous starts.
Roughly speaking, this strategy consists in the following: if nodes have unique identifiers in $\{1,\dots,n\}$,
	the coordinator at round~$t$ is the node whose identifier is  $t$ modulo~$n$.
For that, 	 each node~$u$ maintains a local counter $c_u$
	whose current value is the number of rounds where it has been active.
At each round, the  coordinator of $u$ is the  node with the identifier that is equal to the current value of $c_u$ modulo~$n$.
Since there may be only one coordinator per round, such a selection rule requires synchronous starts.
Clearly, with the use of a $mod-k$-synchronization algorithm in a preliminary phase and a
	counter for each node that now counts the number of rounds elapsed since the node fired, the above scheme correctly\footnote{%
	With respect to a specification that lets a passive node to be  a coordinator.}
	implements the rotating coordinator strategy in the context of asynchronous starts.

% section_model (do not modify this comment)
\section{Preliminaries}\label{sec:model}
 
\subsection{The computational model}
	
We consider a networked system with a {\em fixed} set $V$ of $n$ nodes.
We assume a round-based computational model  in the spirit of the Heard-Of model~\cite{CBS09}, 
	in which point-to-point communications are organized into \emph{synchronized rounds}: 
	each node can send messages  to all nodes and can receive messages sent  by some of the nodes.
Rounds are communication closed in the sense that no node receives messages in round~$t$ that are sent 
	in a round different from~$t$. 
The collection of \emph{possible} communications (which nodes can communicate to which nodes) at each round $t$
	is modelled by a directed graph (digraph, for short) with a set of nodes equal to~$V$.
The digraph at round~$t$ is  denoted $\mathds{G}(t)=(V,E_t)$, and is called the \emph{communication graph at round}~$t$. 
The set of $u$'s incoming neighbors in the digraph $\mathds{G}(t)$ is denoted by $In_u(t)$.

We assume a self-loop at each node in all these digraphs  since every node can communicate with 
	itself instantaneously.	
The sequence of such digraphs~$\mathds{G}=\left (\mathds{G}(t) \right )_{t\in \mathds{N}}$ is called a {\em dynamic graph}~\cite{CFQS11:TVG}. 

In round $t$ ($t = 1, 2 , \ldots $), each node~$ u $ successively
	(a) broadcasts  messages determined by its state at the beginning of round~$ t $
	(b) receives \emph{some} of the messages sent to it,
	and finally (c) undergoes an internal transition to a new state.
A  \emph{local algorithm} for a node corresponds to a pair of
	a \emph{sending function} that determines the messages to be sent in step~(a)
	and a \emph{transition function} for state updates in step (c).
An \emph{algorithm} for the set of nodes~$V$ is a collection of local algorithms, one per node.

We also introduce the notion of  \emph{start schedules}
	that are collections~$\mathds{S}= \left (s_u \right )_{u \in V}$,
	where each~$s_u$ is  a positive integer or is equal to $\infty$.

	
The execution of the algorithm $ A $  with the dynamic graph $\mathds{G}$ and the start schedule $\mathds{S}$ then proceeds
	as follows:
Each node~$u$ is initially  \emph{passive}. 
If $s_u = \infty$, then  the node~$u$ remains passive forever.
Otherwise, $s_u $ is a positive integer, and $u$ becomes {\em active} 
	at the beginning of round~$s_u$, sets up its local variables.
In  round~$t$ $(t = 1,2\dots)$, a passive  node
	sends only heartbeats, corresponding to  \emph{null} messages,  and  cannot change its state. 	
An active node 	applies its sending function in~$A$ to its current state to generate the message to be sent to all nodes,
	then it receives the messages sent by its incoming neighbors in the directed graph~$\mathds{G}(t)$, and finally 
	applies its transition function ${\cal T}_u$ in~$A$ to its current state and the list of messages it has just received,
	(including the null messages from passive nodes) to go to  a next state. 
Since each local algorithm is deterministic, an execution of the algorithm~$A$  is entirely determined 
	by the initial state of the network,  the dynamic graph $\mathds{G}$,
	and  the  start schedule~$\mathds{S}$.
	
The states ``passive'' and ``active'' do not refer to any physical notion, and are relative to the algorithm under consideration:
	as an example, if two algorithms $A$ and $B$ are sequentially executed according to the order ``$A$ followed by $B$'',
	then at some round, a node may be active w.r.t. $A$ while it is passive w.r.t. $B$.
In such a situation, the node  is integrally part of the system and can send messages, but  these messages are empty 
	with respect to the semantics of~$B$.
	
\subsection{Network model and start model}

Let us recall the notion of \textit{product} of two graphs $G_1 = (V, E_1)$ and $G_2 = (V, G_2)$, denoted $G_1 \circ G_2$. This notion is defined in \cite{CBM19}.
$G_1 \circ G_2$ has $V$ as its set of node, and $(u,v)$ is an edge if there exists $w \in V$ such that $(u,w) \in G_1$ and $(w,v) \in G_2$.
For any dynamic graph $\mathds{G}$ and any integer $t' \geq t \geq 1$, we let $\mathds{G}(t:t') = \mathds{G}(t) \circ \mathds{G}(t+1) \circ \dots \circ \mathds{G}(t')$.
When $t' < t$, $\mathds{G}(t:t')$ is the graph with only a self-loop at each node.
Intuitively, the graph $\mathds{G}(t+1:t')$ contains an edge $(u,v)$ if some information about the state of node $u$ in round $t$ may reach node $v$ in round $t'$.
The set of incoming neighbors of $u$ in $\mathds{G}(t:t')$ is noted as $In_u(t:t')$.
A \textit{path from $u$ to $v$ in the interval $[t,t']$} is a finite sequence $(u = w(t), w(t+1), \dots, w(t') = v)$
such that for any $l < t'-t$, the edge $(w(t+l),w(t+l+1))$ belongs to $E_{t+l+1}$.
There exists a path from $u$ to $v$ in the interval $[t,t']$ if and only if $v \in In_u(t+1:t')$.

A \emph{network model} is any non-empty set of dynamic graphs with a permanent self-loop at each node.
We will focus on the specific network model of \emph{centered with delay $k$} dynamic graphs~$\mathds{G}$ defined as follows: 

$$\mathcal{P}_{k-centered} \triangleq \exists \cent \in V, \forall t \in \mathds{N}, \forall u \in V, \cent \in In_u(t+1:t+k).$$

Here, $k$ is the parameter of the $mod-k$-synchronization problem.
There may be several fixed centers for $\mathds{G}$.

Similarly, we define a \emph{start model} as a non-empty set of start schedules.
A start schedule $\mathds{S} = (s_u)_{u\in V}$ is \emph{complete} if every $s_u$ is finite, i.e.,
no node is passive forever, yielding the model of complete start schedules.
Synchronous starts correspond to complete start schedules $\mathds{S} = (s_u)_{u\in V}$ with
equal start rounds.	
The property of synchronous starts can be relaxed into \emph{$mod-k$-synchronous starts},
where $k$ is any positive integer: for every pair of nodes~$u$ and $v$, it holds that $s_u \equiv s_v \!\mod k$.

% section_algorithm (do not modify this comment)
\section{The algorithm}

In this algorithm, the nodes hold a $level$ variable. When they start, they move from passive state to level 0. They later move to level 1, then to level 2.
Each time a node moves from some level to the next, this constitutes a \textit{level-up} event.
A node fires when it reaches level 2.
The conditional statements \ref{line:level1up} and \ref{line:cond-firing} are executed when the node reaches level 1 and 2 respectively.
The intuition of the algorithm can be summarized by two simple ideas:

Firstly, \textbf{each node keeps track of the most recent highest level level-up.}
Only the highest level level-up events are considered: if some node "knows" about a level-up from level 1 to level 2,
it will not record a level-up from level 0 to level 1, nor a level-up from passive state to level 0.
Among the highest level level-up, the nodes keep track of the age of the most recent one.
On that purpose, they hold a $c_u$ and a $force_u$ variable.
At any round, they know that $c_u$ rounds ago, some node reached level $force_u$ from the previous level,
and, in their view, no node reached level $force_u$ (or higher) in any more recent round.
With line \ref{line:force} and \ref{line:min-z-end}, they use at each round the values from their incoming neighbors to update theirs.

Secondly, \textbf{a node may level up only if its counter $c_u$ is congruent to 0 and the counter of $\gamma$ was also congruent to 0 $k$ rounds ago.}
On that purpose, they use a $sync$ boolean variable.
When the counter of some node $u$ becomes congruent to 0 in some round $t$, it sets its $sync_u$ variable to $true$ in line \ref{line:conc-true}.
During all subsequent rounds $t+i$, it will check whether its incoming neighbors are congruent one another (line \ref{line:conc-gossip}).
In the case they are not, the node will set its $sync_u$ variable to $false$ (see figure \ref{fig:fig2}).
This $false$ value will spread in its outgoing neighbors (also line \ref{line:conc-gossip}).
If, in round $t+k$, its $sync_u$ variable is still true, it will know that no non-congruence was detected between round $t$ and round $t+k$.
This means that $\cent$ was congruent with 0 in round $t$.
In that case, a level-up is allowed (see figure \ref{fig:fig1}).
In opposition, if some node $j \in In_u(t+1:t+k)$ is not congruent with 0 in round $t$,
then the line \ref{line:conc-gossip} guarantees that $sync_u$ will ultimately be false at the beginning of round $t+k$ (see figure \ref{fig:fig2}).
In addition to $sync$, the $ready$ variable makes sure that $\cent$ is already at level 1.
If not, the level-up to level 2 is forbidden.

\begin{figure}[h]
    \centering
    \def\svgwidth{0.8\columnwidth}
	\input{/home/louis/Documents/doctorat/images/illustration-conc-1.pdf_tex}
	\caption{case where $sync_u$ is true}
	\label{fig:fig1}
\end{figure}

\begin{figure}[h]
    \centering
    \def\svgwidth{0.8\columnwidth}
	\input{/home/louis/Documents/doctorat/images/illustration-conc-2.pdf_tex}
	\caption{case where $sync_u$ is false}
	\label{fig:fig2}
\end{figure}


\begin{algorithm}[htb]
	\DontPrintSemicolon
	\textbf{Initialization:} \;
	\Indp
		$c_u \in \mathds{N}$, initially 0 \;
		$sync_u \leftarrow false$ \;
		$ready_u \leftarrow false$ \;
		$force_u \in \{0, 1, 2\}$, initially 0 \;
		$level_u \in \{0, 1, 2\}$, initially 0 \;
	\BlankLine
	\Indm
	\textbf{At each round $r$:} \;
	\Indp
		send $\langle c_u, sync_u, force_u, ready_u \rangle$ to all  \;
		receive incoming messages from all $v \in In_u(r)$ \;
		$sync_u \leftarrow \forall v \in In_u(r), sync_v \wedge c_v \equiv c_u [k]$ and no null received \; \label{line:conc-gossip}
		$ready_u \leftarrow \forall v \in In_u(r), ready_v$ \; \label{line:ready-gossip} 
		$force_u \leftarrow max \{force_v, v \in In_u(r) \}$ \;\label{line:force}
		$c_u \leftarrow 1+ min \{c_v, v \in In_u(r) \wedge force_v = force_u\}$ \;\label{line:min-z-end} 
		\If{$c_u \equiv 0 [k]$}{ \label{line:cond-levelup} 
			\If{$level_u = 0 \wedge sync_u$}{ \label{line:level1up}
				$level_u \leftarrow 1$ \;
				$force_u \leftarrow max(1, force_u)$ \; \label{line:force2}
				$c_u \leftarrow 0$ \; \label{line:force3}
			}
			\ElseIf{$level_u = 1 \wedge ready_u \wedge sync_u$}{ \label{line:cond-firing}
				$force_u \leftarrow 2$ \;
				$level_u \leftarrow 2$ \tcc*[f]{reaching level 2 => fire}\;
				$c_u \leftarrow 0$ \; 
			}
			$sync_u \leftarrow true$ \; \label{line:conc-true}
			$ready_u \leftarrow level_u > 0$ \; \label{line:init-ready}
		}
	\Indm
\caption{The $SyncMod$ algorithm} 
\end{algorithm}

We consider an execution of the $SyncMod$ algorithm.
We note $c_u(t), sync_u(t), \dots$ the value of the $c, sync, \dots$ variables of node $u$ at the end of round $t$, if $u$ is active in round $t$.
We also note $c^-_u(t), sync^-_u(t), \dots$ the value of the $c, sync, \dots$ variables
of node $u$ in line \ref{line:cond-levelup} during round $t$, if $u$ is active in round $t$.
We now prove that this execution verifies the safety and liveness properties of the $mod-k$-synchronization problem.

\begin{lem} \label{lem:conc-safety}
	Let $i$ be an integer verifying $0 < i \leq k$, let $t$ be a round. Let $u$ and $v$ be two nodes such that there exists a path from $u$ to $v$ in the interval $[t+i,t+k]$.
	If $c^-_v(t+k) \equiv 0 [k] \wedge sync^-_v(t+k)$, then $c_u^-(t+i) \equiv i [k]$.
\end{lem}
\begin{proof}
	Let $u = w(t+i), \dots, w(t+k) = v$ be the path between $u$ and $v$.
	By a backward induction, we show that every node $w(t+j)$ on this path is active
	and verifies $c_{w(t+j)}^-(t+j) \equiv j [k]$ and $sync_{w(t+j)}^-(t+j)$.

	The base case is the hypothesis of the lemma.
	For the induction case, we assume that $i \leq j < k$, and $c_{w(t+j+1)}^-(t+j+1) \equiv j+1 [k]$ and $sync_{w(t+j+1)}^-(t+j+1)$.
	We know that $w(t+j)$ sent to $w(t+j+1)$ in round $t+j+1$ either a null message, or a message of the form $\langle x, sync_{w(t+j)}(t+j), *, * \rangle$.
	From line \ref{line:conc-gossip}, we get that $w(t+j)$ is active in round $t+j$ and $sync_{w(t+j)}(t+j)$ is true. Moreover, the received messages are congruent.
	Then, from line \ref{line:min-z-end} and the induction hypothesis, we get $c_{w(t+j+1)}^-(t+j+1) \equiv x+1 \equiv j+1 [k]$.
	Finally $c_{w(t+j)}^-(t+j) \equiv c_{w(t+j)}(t+j) \equiv j [k]$.
\end{proof}

\noindent Using similar reasoning, we can prove the following lemma.
\begin{lem} \label{lem:conc-safety-bis}
	If $sync_u^-(t+k) \wedge ready_u^-(t+k) \wedge c_u^-(t+k) \equiv 0 [k]$, then $level_\cent(t) \geq 1$.
\end{lem}
\begin{proof}
	We consider a path $(\cent = w(t), \dots, w(t+k) = u)$. Such a path exist because we assumed that $\mathcal{P}_{k-centered}$.
	We can show using a backward induction along this path that any node $w(t+i)$ with $0 \leq i < k$ on this path is active and verifies
	$sync_{w(t+i)}(t+i) \wedge ready_{w(t+i)}(t+i) \wedge c_{w(t+i)}(t+i) \equiv i [k]$.
	We eventually get $ready_\cent(t) \wedge c_\cent(t) \equiv 0 [k]$. The line \ref{line:init-ready} terminates the proof.
\end{proof}

\begin{lem} \label{lem:no-close-level2}
	If $\cent$ reaches level 1 in round $t+k$, no node can level up in any round between $t+k+1$ and $t+2k-1$.
\end{lem}
\begin{proof}
	We assume that some node $u$ levels up in round $t+k+i$ where $i \in \{1, \dots, k-1\}$.
	We apply the lemma \ref{lem:conc-safety} to $u$ and $\cent$.
	We use the path between $\cent$ and $u$ in the interval $[t+i,t+k+i]$ and the path between $\cent$ and $\cent$ in the interval $[t+i,t+k]$ respectively.
	These paths are guaranteed to exist because of $\mathcal{P}_{k-centered}$ and the assumption of existence of self-loops respectively.
	We get respectively $c_\cent^-(t+i) \equiv 0 [k]$ and $c_\cent^-(t+i) \equiv i [k]$.
	We get a contradiction from $i \equiv 0 [k]$.
\end{proof}

\begin{lem} \label{lem:safety-force}
	If $c_u^-(t) = i$, then some node must have reached a level equal to $force_u^-(t)$ in round $t-i$.
\end{lem}
\begin{proof}
	We show this lemma by induction on $i \in \mathds{N}$.
	The base case is trivial (see line \ref{line:min-z-end}).
	For the induction case, we assume that $c_u^-(t) = i+1$.
	Then, $u$ received sent to $u$ a message of the form $\langle i, *, force_u^-(t), * \rangle$ from some node $v$ (see lines \ref{line:force} and \ref{line:min-z-end}).
	If $i = 0$, then $v$ is the node which satisfies the lemma.
	Otherwise $i = c_v^-(t-1)$.
	We conclude with the induction hypothesis.
\end{proof}

Given the lines \ref{line:force} and \ref{line:min-z-end}, this lemma tells us that $c_u$ and $force_u$ actually points to the most recent highest level level-up.

\begin{lem} \label{lem:ready-safety}
	If node $u$ reaches level 2 in round $t$, then $\cent$ must have reached level 1 in a previous round $t-i$.
	Moreover $c^-_u(t) \leq i$.
\end{lem}
\begin{proof}
	The first part of the lemma results from lemma \ref{lem:conc-safety-bis}. We now prove the second part.
	If $force_u^-(t) = 2$, then, using lemma \ref{lem:safety-force}, some node $v$ reached level 2 in the round $t-c_u^-(t)$.
	From the first part of the lemma, we get $c_u^-(t) \leq i$. 

	If $force_u^-(t) = 1$, then, from lemma \ref{lem:safety-force}, some node $v$ reached level 1 in the round $t-c_u^-(t)$.
	The lemma \ref{lem:no-close-level2} tells us that $i \geq k$.
	Using $\mathcal{P}_{k-centered}$, we obtain $\cent \in In_u(t-i+1:t)$.
	The level-up of $v$ to level 1 must be more recent than the level-up of $\cent$ to level 1.
	Then $c_u^-(t) \leq i$.
\end{proof}

\begin{lem} \label{lem:later-level1}
	If $\cent$ reached level 1 in round $t$, whereas $u$ levels up later in round $t+i$, then $i \equiv 0 [k]$. 
\end{lem}
\begin{proof}
	By contradiction, we consider the earliest node $u$ which levels up in round $t+i$ with $i \not\equiv 0 [k]$.

	In the case $force_u^-(t+i) = 2$, the lemma \ref{lem:safety-force} implies the existence of a node $v$ which reached level 2 in some round $t'$. 
	From lemma \ref{lem:ready-safety}, we get $t' \geq t$.

	In the case $force_u^-(t+i) \leq 1$, the lemma \ref{lem:safety-force} implies the existence of a node $v$ which reached level 0 or 1 in some round $t' = t+i-c_u^-(t+i)$. 
	The case $i < k$ is impossible according to lemma \ref{lem:no-close-level2}.
	Then, using $\mathcal{P}_{k-centered}$, we obtain $\cent \in In_u(t+1:t+i)$.
	Since $u$ "knows" in round $t+i$ that $\cent$ and $v$ both leveled up in round $t$ and $t'$ respectively, and adopted $c_u^-(t+i) = t+i-t'$ rather than $i$,
	we also get $t' \geq t$.
	In both cases, from line \ref{line:cond-levelup}, we get $t' \equiv t+i [k]$.
	This contradicts the fact that $u$ was the earliest non-congruent node.
\end{proof}

\begin{thm} \label{lem:safety} 
	The algorithm is safe.
\end{thm}
\begin{proof}
	The safety is a consequence of lemmas \ref{lem:ready-safety} and \ref{lem:later-level1}.
\end{proof}

\begin{lem}
	The algorithm is live
\end{lem}
\begin{proof}
	We consider the set $L = \{(f,t), \exists u \in \Pi, level_u(t) = f \wedge level_u(t-1) \neq f\}$.
	This set represents the finite set of level-up events.
	Using lemma \ref{lem:safety-force}, any node $u$ verifies $(t-c_u(t), force_u(t)) \in L$ in every round $t$.
	We note this tuple as $z_u(t)$.
	We can order $Z$ with the lexical ordering.
	The algorithm is designed such that for any node $u$, the sequence $z_u$ is increasing, and eventually stabilizes to $z_u^{max}$.
	Let $z^{min}$ be $min \{z_u^{max}, u \in \Pi\}$.
	We consider the round $t$ in which every node is active, and from which its $z_u$ sequence is stabilized.
	We consider the subset $\Pi_{min} = \{u \in \Pi, z_u^{max} = z^{min}\}$.
	We can prove that $\forall t' > t, \forall u \in \Pi_{min}, In_u(t') \subseteq \Pi_{min}$.
	Otherwise, $u$ would adopt a $z_u(t') > z_u^{max}$.
	Intuitively, $\Pi_{min}$ is a set of nodes which can only receive message from $\Pi_{min}$.
	At some point between rounds $t$ and $t+k$, the nodes in $\Pi_{min}$ will simultaneously execute line \ref{line:conc-true}.
	From this point, the expression in line \ref{line:conc-gossip} can only be true.
	Every node $u \in \Pi_{min}$ verifies $sync_u(t') = true$.
	Then the nodes in $\Pi_{min}$ are already in level 2, otherwise they would eventually level up (that would increase their $z_u$).
	A fortiori, every other node is already in level 2.
	That proves liveness.
\end{proof}

\subsection{Limitations and possible extensions of $SynchMod$ algorithm}

\begin{cor}
	The $mod-k$-synchronization problem is not solvable in a system where the communication graph is centered with an unknown delay $D$.
\end{cor}
\begin{proof}
	By contradiction, we assume that an algorithm $A$ solves this problem.
	We construct an execution of $A$ in a system composed of a unique node $u$, starting in round 1.
	By termination property, the node $u$ in this execution must terminate in some round $t$.
	We construct an execution of $A$ in a system composed of a two nodes $u$ and $v$. The node $u$ starts in round 1 whereas $v$ starts in round 2.
	We construct a communication graph where $u$ and $v$ are both insulated during the first $t+2$ rounds, and become connected at round $t+3$.
	This graph is centered with delay $t+3$.
	Both $u$ and $v$ will terminate in round $t$ and $t+1$ respectively, because they cannot distinguish this execution from the execution previously described.
	This contradicts the $mod-k$-synchronization hypothesis.
\end{proof}

\begin{cor}
	The $mod-k$-synchronization problem is solvable in a system where the communication graph is centered with a known delay $D$.
\end{cor}
\begin{proof}
	We just showed that $mod-k$-synchronization is solvable if the communication graph is centered with delay $k$.
	If $D < k$, then a fortiori, the graph is also centered with delay $k$.
	If $D > k$, we know that the $mod-\lceil \frac{D}{k} \rceil \times k$-synchronization is solvable using $SynchMod$.
	A fortiori, the $mod-k$-synchronization is solvable.
\end{proof}

% section_cons (do not modify this comment)
\section{Use-cases of $mod-k$-synchronization}

\subsection{Algorithms without safety assumption}

Let us consider a given algorithm $A$, which can solve a problem $\mathcal{A}$ when the starts are synchronous.
The correctness of $A$ may depend on some assumptions.
Usually, the assumptions required for safety are expressed as invariants on the dynamic graph: $\forall r \in \mathds{N}, P_{saf}(\mathds{G}_r)$.
Whereas the assumptions required for liveness are expressed as infinitely often verified predicates on the dynamic graph: $\forall r \in \mathds{N}, \exists r' > r, P_{liv}(\mathds{G}_{r'})$.
The case where no invariant is required for safety is easier to deal with. At first we focus on this case.

We assume that $A$ is structured as $k$ rotating phases, which means that $A$ needs $mod-k$-synchronization.
We construct the algorithm $SynchMod_k \lozenge A$ in the following way:
we consider a node $u$. 
\begin{enumerate}
	\item At first, $u$ is passive, and sends null messages, according to the model.
	\item From round $s_u$, the node $u$ is active. It starts the $SyncMod$ algorithm. It sends and receives messages according to the $SyncMod$ algorithm and ignore the messages related to $A$.
	\item In round $\tf_u$, the node $u$ fires. From this round, $u$ executes $SyncMod$ in parallel with $A$. Both $A$ and $SyncMod$ send and receive messages according to their pseudo-code.
		In some cases, $u$ may receive from a neighbor $v$ a message related to $SyncMod$, and no message related to $A$. Then $u$ can guess that $v$ has not fired yet.
		The $A$ instance of $u$ interpret that as a null message received from $v$.
\end{enumerate}

We now wonder whether $SynchMod_k \lozenge A$ solves $\mathcal{A}$ with asynchronous starts, and how $A$ should deal with null message.
In the case without required invariant, $A$ could assimilate null messages as lost messages,
and we could reasonably expect that $SynchMod_k \lozenge A$ solves $\mathcal{A}$ with asynchronous starts.
Indeed, the drop of the null messages in $A$ is equivalent with the drop of some edges in the dynamic graph.
The safety proof without invariant is not affected by the modification of the dynamic graph, and should be easily extended from synchronous starts system to asynchronous starts system.
Moreover, if we assume that no node remains passive forever, no edge is dropped in the dynamic graph beyond a certain round.
Then, the liveness proof with synchronous starts should be still valid if applied from that round.

Some notable examples of algorithms which can be adapted with this approach include the LastVoting \cite{CBS09} algorithm (an round-based adaptation of Paxos \cite{paxos}) which solves consensus,
and the ThreePhaseCommit \cite{BT93} algorithm, which solves the database commit problem.

\subsection{Algorithms with safety assumption}

When the safety proof of an algorithm relies on some invariant, the drop of edges in the dynamic graph might break the safety proof.
A possible fix could consist in changing the way the algorithm $A$ deals with null message. This must be done in a case-by-case basis.
We exemplify that with an adaptation of the UniformVoting \cite{CBS09} \cite{Ben83} algorithm.


\begin{algorithm}[htb]
	\DontPrintSemicolon
	\textbf{Initialization:} \;
	\Indp
		$x_u := v_u$ ~~~~~~~~\{\emph{$v_u$ is the initial value of $p$}\} \;
		$vote_u \in V\cup\{ ? \}$, initially $?$ \;
		$phase_u = true$ ~~~~~~\{\textit{variable which organises the two-phase rotation}\} \;
	\BlankLine
	\Indm
	\textbf{At each round $r$:} \;
	\Indp
		\If{$phase_u$}{
			send $\langle x_u , vote_u \rangle$ to all
		}
		\Else{send $\langle x_u \rangle$ to all}
		receive incoming messages \;
		\If{$phase_u$}{
			\If{a node voted for $v$}{
				$x_u:= v$ \label{line:adopt_vote}
			}
			\Else{
				$x_u :=$ smallest  $w$ from  $\langle w , ? \rangle$ received \label{line:min_vote} \;
				\If{every node voted for $v$, none sent null}{ \label{line:cond1}
					$DECIDE(v)$ \;
					$vote_u :=\ ?$ \;
				}
			}
		}
		\Else{
			$ x_u :=$ minimum value received (excluding null) \label{line:min_val} \;
			\If{every node sent $v$, none sent null}{ \label{line:cond2}
				$vote_u := v$
			}
		}
		$phase_u := \neg phase_u$ \;
	\Indm
\caption{The {\em AdaptedUniformVoting} algorithm}
\end{algorithm}

This pseudo-code is almost identical to the pseudo-code used in the systems with synchronous starts.
However, you can see that in lines \ref{line:cond1} and \ref{line:cond2}, the effect of the null messages is precised.
In that case, the null messages are not dropped. They prevent the nodes from voting and deciding.

It is possible to prove the following theorem:

\begin{thm}
	The $SynchMod_4 \lozenge AdaptedUniformVoting$ algorithm solves the consensus problem under the condition of a centered dynamic graph and a complete activation schedule.
\end{thm}

The proof of validity and agreement for UniformVoting given in \cite{CBS09} can easily be transposed to \newline $SynchMod_4 \lozenge AdaptedUniformVoting$.
The proof of termination, which is radically different, is detailed below.

\begin{proof}
	We consider an execution of $SynchMod_4 \lozenge AdaptedUniformVoting$.
	Let $r$ be the round in which $\cent$ fires.
	In round $r+1$, the $AdaptedUniformVoting$ algorithm is started by $\cent$.

	We claim that the sequence $(x_\cent(r+i+1))_{i \in \mathds{N}}$ is decreasing.
	\begin{enumerate}
		\item If $i+2$ is odd, the line \ref{line:min_val} guarantees that $x_\cent(r+i+2) \leq x_\cent(r+i+1)$.
		\item If $i+2$ is even and a node $u$ voted for $v$, the only possibility is $v = x_\cent(r+i+1)$. This is because $\cent$ sent $x_\cent(r+i+1)$ to $u$ in round $r+i+2$.
			Then $x_\cent(r+i+2) = x_\cent(r+i+1)$.
		\item If $i+2$ is even and no node voted, the line \ref{line:min_vote} guarantees that $x_\cent(r+i+2) \leq x_\cent(r+i+1)$.
	\end{enumerate}
	That proves the claim.

	Since this series is decreasing, and the set of initial decision values is finite, it must reach a minimum.
	We consider the earliest round $r_0 \geq \phi^{max}$ in which every node have already fired and the series has stabilized to $v$.

	Without loss of generality, we assume that the round $r_0+1$ is a round of exchange of value (i.e. $\forall u \in \Pi, \neg phase_u(r_0)$).
	Since $x_\cent(r_0+1) = x_\cent(r_0)$, we know that $\cent$ only receives messages containing $v$ in round $r_0+1$ (see line \ref{line:min_val}).
	Then $\cent$ must vote $v$ in round $r_0+2$ (see line \ref{line:cond2}).
	Then every node must adopt $v$ in round $r_0+2$ (see line \ref{line:adopt_vote}).
	Then, in round $r_0+3$ every node must send $v$ to all.
	Then, in round $r_0+3$ every node can only receive $v$.
	Then, in round $r_0+3$ every node must vote for $v$ (see line \ref{line:cond2}).
	Then, in round $r_0+4$ every node must decide $v$.
	That proves termination.
\end{proof}

\subsection{$mod-n$-synchronization and coordinated algorithms}

Some algorithms like Paxos rely on the existence of a shared coordinator in each round.
A simple implementation consists in setting a rotating coordinator: 
each node holds the list of nodes. In the first round, the chosen coordinator is the first node in the list.
In the $i^{th}$ round, the chosen coordinator is the $i~mod~n^{th}$ node on the list.
This works out-of-the box when the starts are assumed to be synchronous.
However, when the starts are asynchronous, a prior $mod-n$-synchronization is required, where $n$ is the number of nodes in the shared list.
This is another typical use case of the $SyncMod$ algorithm.

\subsection{A much simpler approach ?}

In the case of the problem of consensus, we have mentioned in a previous paragraph the possibility to use Paxos.
Since we only consider synchronous systems, much simpler algorithms like FloodSet \cite{Lyn96} exists.
As mentioned in \cite{CDDS85}, the FloodSet algorithm can be adapted to solve consensus in a system with asynchronous starts.
Using a variant of the firing squad algorithm (called $AdaptedFiringSquad_f$ here),
where the nodes hold a counter $c_u \in \mathds{N}$, and fire when they reach an upper bound $f$ on the number of failure.
Using $AdaptedFiringSquad_f \lozenge FloodSet$, we get a simple consensus algorithm.
This approach has some shortcomings, though.
Firstly, the nodes have to "know" an shared upper bound on the number of failures.
Then, only the simplest form of failure is supported: the crash-failures.
More importantly, this method achieves \textit{non-uniform} consensus: only the non-crashed nodes are required to decide.

% section_conclusion (do not modify this comment)
\section{Conclusion and future work}

As any complex reasoning by cases, the correctness proof  of the $SyncMod$   algorithm, 
	and more specifically the proof of the liveness property, is very error prone. 
This is a typical example of the relevance of formal verification for distributed algorithms. 
Indeed, in a later work~\cite{}, we used the interactive theorem prover Isabelle \cite{Merz12} to encode the complete proof 
	of Theorem~\ref{thm:k>2}, and thus obtained a certificate for  $SyncMod$\!\!'s correctness when $k$ is greater than 2.
	
Since $mod-2$-synchronization is reducible to $mod-4$-synchronization,
	 our algorithm solves the $mod-k$-synchronization problem for any positive integer~$k$
	 in the class of  dynamic  graphs with a fixed center.
This class of dynamic graphs plays a crucial role regarding benign failures as it captures 
	the synchronous model with at most $n-1$ faulty senders, including the one with at most $n-1$ crashes.
In the wilder context of dynamic graphs, a natural question is whether the problem is still solvable 
	under weaker connectivity assumptions, in particular, in the class of dynamic graphs with a fixed root, 
	i.e., with a time-varying spanning tree at each round rooted at a fixed node.

% end_section (do not modify this comment)

\printbibliography

\end{document}
