\documentclass[11pt,letterpaper]{article}
\special{papersize=8.5in,11in}

\usepackage{fullpage}
\usepackage{amsmath,amssymb,amsthm,dsfont}
\usepackage{xcolor}
\usepackage{float}
\usepackage{tikz}
\usepackage{import}
\usetikzlibrary{shapes.symbols,arrows}

\usetikzlibrary{shapes.symbols,arrows}
\usepackage{enumerate}

\newtheorem{thm}{Theorem}
\newtheorem{pro}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{cor}[thm]{Corollary}
\newtheorem{defi}[thm]{Definition}

\usepackage[ruled, linesnumbered, noline]{algorithm2e}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[utf8]{inputenc}
\usepackage[pdftex,pdfpagelabels,bookmarks,hyperindex,hyperfigures]{hyperref}

\usepackage{biblatex}
\addbibresource{dynamic.bib}
\addbibresource{bibase.bib}

\newcommand{\cent}{\gamma}

\newcommand{\ts}{s}
\newcommand{\tf}{\phi}
\newcommand{\try}{\tau}

\title{Synchronization Modulo $k$ in Dynamic Networks}
\author{
	Bernadette Charron-Bost \\
	LIX, Palaiseau, France
\and
	Stephan Merz \\
	LORIA, Nancy, France
\and
	Louis Penet de Monterno \\
	LIX, Palaiseau, France
}
\date{\today}

\begin{document}

\maketitle
\tableofcontents

\begin{abstract}
	We define the mod k—synchronization problem as a weakening of the Firing Squad problem,
	where all nodes fire not at the same round, but at rounds that are all equal modulo k.
	We propose an algorithm that achieves mod k—synchronization  in any dynamic network
	with a fixed spanning star. As opposed to the perfect synchronization in
	the Firing Squad problem, mod k—synchronization thus does not require
	any strong connectivity property in the network. 
	Then, we develop our approach for the consensus problem,
	and present different consensus algorithms that all tolerate asynchronous starts.
\end{abstract}

% section_intro (do not modify this comment)
\section{Introduction}

Distributed algorithms are often designed in a synchronous computing model, in which computation
	is divided into communication {\em closed rounds}:
	any message  sent at some round  can be received only at that round.
In this model it is classically assumed that each run of an algorithm is started by all nodes simultaneously, i.e., at the same round,
	or even at round one.
For instance, most of synchronous consensus algorithms
	(e.g.,~\cite{PSL80,DS83,ST87}), as well as many distributed algorithms for dynamic networks (e.g.,~\cite{KLO10,KMO11})
	require synchronous starts.

This assumption makes the sequential composition of two distributed algorithms $A;B$
	-- in which each node starts executing $B$ when it has completed the execution of~$A$ --
	quite problematic.
Indeed, nodes start the algorithm~$B$ asynchronously when the algorithm~$A$ terminates asynchronously,
	and the properties of~$B$ are no more guaranteed in this context of asynchronous starts.

This leads to the problem of simulating synchronous starts, classically referred to as
	the {\em firing squad problem}:
Each node is  initially  {\em passive} and then become {\em active}  at an unpredictable round.
The goal is to guarantee that   the nodes, when all active, eventually synchronize
	by {\em firing} -- i.e., entering a designated state for the first time -- at the same round.

Unfortunately, the impossibility result in~\cite{CBM18} demonstrates that the firing squad problem
	is not solvable without a strong connectivity property of the network, namely, there exists  some positive
	integer~$T$ such that communication graph within  every period of $T$ consecutive
	rounds is strongly connected and the delay~$T$ is known.
In many situations,  this connectivity property is not guaranteed:
	as an example, in the dynamic graphs corresponding to any system model with benign failures,
	a node  that experiments permanent and complete send omissions
	is  constantly a sink in the  communication graph.

However, with a closer look at many distributed algorithms designed in the round-based model,  we see that
	these algorithms actually  do not require perfect synchronous starts, and still work under the weaker condition that all the nodes
	start executing the algorithms in rounds with numbers that are equal modulo~$k$, for some positive integer~$k$.
The corresponding synchronization problem, that we call $mod-k$  \emph{synchronization}, is formally specified as follows:
	\begin{description}
	\item[Termination:]   If all nodes are eventually active, then  every node eventually fires.
	\item[ $\mathbf{mod-k}$-simultaneity:]  If two nodes fire at round~$t$ and $t'$, then $t' \equiv t \mod k$.
	\end{description}

Indeed, let $A$ be an algorithm  organized into regular  \emph{phases} consisting of  a fixed number  $k$ of consecutive rounds:
	the sending and transition functions of every node at round~$t$ are entirely determined by the value of~$t$ modulo~$k$.
Moreover, assume that $A$ has been proved correct (with respect to some given specification) when all nodes start $A$
	synchronously (at round one) and with any dynamic graph in a family~${\cal G}$ that is stable  under
	addition of arbitrary finite prefixes.
For instance, the \emph{ThreePhaseCommit} algorithm for non-blocking atomic commitment~\cite{BHG87},
	as well as the consensus algorithms in~\cite{DLS88} or the \emph{LastVoting} algorithm ~\cite{CBS09}
	-- corresponding to the consensus core of \emph{Paxos} -- fulfill all the above requirements
	for phases of length $k=3$ and $k=4$, respectively, and the family ${\cal G}$ of dynamic graphs in which
	there exists an infinite number of ``good'' communication patterns
	(eg., a sequence of $2k-1$ consecutive communication graphs  in which a majority of nodes is heard by all
	in   each graph).
The use of a $mod-k$-synchronization algorithm on the top of the algorithm $A$ yields a new algorithm that executes
	exactly like $A$ does, after a finite preliminary period during which every node becomes active and fires.
The above property on the set of dynamic graphs ${\cal G}$ then guarantees this variant of $A$ to be correct with
	asynchronous starts and dynamic graphs in ${\cal G}$.

Another typical example for which perfect synchronization can be weakening into synchronization modulo $k$ is
	the development of the basic \emph{rotating coordinator} strategy in the context of asynchronous starts.
Roughly speaking, this strategy consists in the following: if nodes have unique identifiers in $\{1,\dots,n\}$,
	the coordinator at round~$t$ is the node whose identifier is  $t$ modulo~$n$.
For that, 	 each node~$u$ maintains a local counter $c_u$
	whose current value is the number of rounds where it has been active.
At each round, the  coordinator of $u$ is the  node with the identifier that is equal to the current value of $c_u$ modulo~$n$.
Since there may be only one coordinator per round, such a selection rule requires synchronous starts.
Clearly, with the use of a $mod-k$-synchronization algorithm in a preliminary phase and a
	counter for each node that now counts the number of rounds elapsed since the node fired, the above scheme correctly\footnote{%
	With respect to a specification that lets a passive node to be  a coordinator.}
	implements the rotating coordinator strategy in the context of asynchronous starts.

% section_model (do not modify this comment)
\section{Preliminaries}\label{sec:model}
 
\subsection{The computational model}
	
We consider a networked system with a {\em fixed} set $V$ of $n$ nodes.
We assume a round-based computational model  in the spirit of the Heard-Of model~\cite{CBS09}, 
	in which point-to-point communications are organized into \emph{synchronized rounds}: 
	each node can send messages  to all nodes and can receive messages sent  by some of the nodes.
Rounds are communication closed in the sense that no node receives messages in round~$t$ that are sent 
	in a round different from~$t$. 
The collection of \emph{possible} communications (which nodes can communicate to which nodes) at each round $t$
	is modelled by a directed graph (digraph, for short) with a set of nodes equal to~$V$.
The digraph at round~$t$ is  denoted $\mathds{G}(t)=(V,E_t)$, and is called the \emph{communication graph at round}~$t$. 
The set of $u$'s incoming neighbors in the digraph $\mathds{G}(t)$ is denoted by $In_u(t)$.

We assume a self-loop at each node in all these digraphs  since every node can communicate with 
	itself instantaneously.	
The sequence of such digraphs~$\mathds{G}=\left (\mathds{G}(t) \right )_{t\in \mathds{N}}$ is called a {\em dynamic graph}~\cite{CFQS11:TVG}. 

In round $t$ ($t = 1, 2 , \ldots $), each node~$ u $ successively
	(a) broadcasts  messages determined by its state at the beginning of round~$ t $
	(b) receives \emph{some} of the messages sent to it,
	and finally (c) undergoes an internal transition to a new state.
A  \emph{local algorithm} for a node corresponds to a pair of
	a \emph{sending function} that determines the messages to be sent in step~(a)
	and a \emph{transition function} for state updates in step (c).
An \emph{algorithm} for the set of nodes~$V$ is a collection of local algorithms, one per node.

We also introduce the notion of  \emph{start schedules}
	that are collections~$\mathds{S}= \left (s_u \right )_{u \in V}$,
	where each~$s_u$ is  a positive integer or is equal to $\infty$.

	
The execution of the algorithm $ A $  with the dynamic graph $\mathds{G}$ and the start schedule $\mathds{S}$ then proceeds
	as follows:
Each node~$u$ is initially  \emph{passive}. 
If $s_u = \infty$, then  the node~$u$ remains passive forever.
Otherwise, $s_u $ is a positive integer, and $u$ becomes {\em active} 
	at the beginning of round~$s_u$, sets up its local variables.
In  round~$t$ $(t = 1,2\dots)$, a passive  node
	sends only heartbeats, corresponding to  \emph{null} messages,  and  cannot change its state. 	
An active node 	applies its sending function in~$A$ to its current state to generate the message to be sent to all nodes,
	then it receives the messages sent by its incoming neighbors in the directed graph~$\mathds{G}(t)$, and finally 
	applies its transition function ${\cal T}_u$ in~$A$ to its current state and the list of messages it has just received,
	(including the null messages from passive nodes) to go to  a next state. 
Since each local algorithm is deterministic, an execution of the algorithm~$A$  is entirely determined 
	by the initial state of the network,  the dynamic graph $\mathds{G}$,
	and  the  start schedule~$\mathds{S}$.
	
The states ``passive'' and ``active'' do not refer to any physical notion, and are relative to the algorithm under consideration:
	as an example, if two algorithms $A$ and $B$ are sequentially executed according to the order ``$A$ followed by $B$'',
	then at some round, a node may be active w.r.t. $A$ while it is passive w.r.t. $B$.
In such a situation, the node  is integrally part of the system and can send messages, but  these messages are empty 
	with respect to the semantics of~$B$.
	
\subsection{Network model and start model}

Let us recall the notion of \textit{product} of two graphs $G_1 = (V, E_1)$ and $G_2 = (V, G_2)$, denoted $G_1 \circ G_2$. This notion is defined in \cite{CBM19}.
$G_1 \circ G_2$ has $V$ as its set of node, and $(u,v)$ is an edge if there exists $w \in V$ such that $(u,w) \in G_1$ and $(w,v) \in G_2$.
For any dynamic graph $\mathds{G}$ and any integer $t' > t \geq 1$, we let $\mathds{G}(t:t') = \mathds{G}(t+1) \circ \mathds{G}(t+2) \circ \dots \circ \mathds{G}(t')$.
When $t' \leq t$, $\mathds{G}(t:t')$ is the graph with only a self-loop at each node.
Intuitively, the graph $\mathds{G}(t:t')$ contains an edge $(u,v)$ if some information about the state of node $u$ in round $t$ may reach node $v$ in round $t'$.
The set of incoming neighbors of $u$ in $\mathds{G}(t:t')$ is noted as $In_u(t:t')$.

A \emph{network model} is any non-empty set of dynamic graphs with a permanent self-loop at each node.
We will focus on the specific network model of \emph{centered with delay $k$} dynamic graphs~$\mathds{G}$ defined as follows: 

$$\mathcal{P}_{k-centered} \triangleq \exists \cent \in V, \forall t \in \mathds{N}, \forall u \in V, \cent \in In_u(t:t+k).$$

Here, $k$ is the parameter of the $mod-k$-synchronization problem.
In other words, for any $u$ and $t$, there must exist a path $(\cent = j(0), j(1), \dots, j(k) = u)$ such that $\cent$ can communicate with $j(1)$ in round $t$ (i.e. $j(0) \in In_{j(1)}(t)$),
$j(1)$ can communicate with $j(2)$ in round $t+1$ (i.e. $j(1) \in In_{j(2)}(t+1)$), and so on.

Note that there may be several fixed centers for $\mathds{G}$.

Similarly, we define a \emph{start model} as a non-empty set of start schedules.
A start schedule $\mathds{S} = (s_u)_{u\in V}$ is \emph{complete} if every $s_u$ is finite, i.e.,
no node is passive forever, yielding the model of complete start schedules.
Synchronous starts correspond to complete start schedules $\mathds{S} = (s_u)_{u\in V}$ with
equal start rounds.	
The property of synchronous starts can be relaxed into \emph{$mod-k$-synchronous starts},
where $k$ is any positive integer: for every pair of nodes~$u$ and $v$, it holds that $s_u \equiv s_v \!\mod k$.

% section_algorithm (do not modify this comment)
\section{The algorithm}

In this algorithm, the nodes hold a $level$ variable. When they start, they are level 0. They eventually reach level 1 then level 2.
A node fires when it reaches level 2.
The conditional statements \ref{line:level1up} and \ref{line:cond-firing} are executed when the node reaches level 1 and 2 respectively.
The intuition of the algorithm can be summarized by two simple ideas:

Firstly, \textbf{each node keep track of the most recent highest level level-up.}
On that purpose, they hold a $c_u$ and a $force_u$ variable.
At any round, they know that $c_u$ rounds ago, some node reached level $force_u$ from the previous level,
and, in their available history, no node reached level $force_u$ (or higher) in any more recent round.
With line \ref{line:force} and \ref{line:min-z-end}, they use the values from their incoming neighbors to update theirs.

Secondly, \textbf{a node may level-up only if it is in sync with the center.}
A nodes can level-up in round $t$ if its counter $c_u$ is congruent with 0.
A subset $In_u(t-k:t)$ of nodes were able to transmit some information about their state in round $t-k$ to $u$ in round $t$
(those nodes are the left-most nodes in the figures \ref{fig:fig1} and \ref{fig:fig2}).
By hypothesis, the center belongs to this set.
We want to guarantee that the value of the center in round $t-k$ is congruent to 0.
However, since the nodes cannot know the identity of the center from the other nodes, they conservatively level-up only if every node
in $In_u(t-k:t)$ is congruent to 0 in round $t-k$.
The variable $conc_u$ is aimed at determining this.

\begin{figure}[h]
    \centering
    \def\svgwidth{0.8\columnwidth}
	\input{/home/louis/Documents/doctorat/images/illustration-conc-1.pdf_tex}
	\caption{case where $conc_u$ is true}
	\label{fig:fig1}
\end{figure}

\begin{figure}[h]
    \centering
    \def\svgwidth{0.8\columnwidth}
	\input{/home/louis/Documents/doctorat/images/illustration-conc-2.pdf_tex}
	\caption{case where $conc_u$ is false}
	\label{fig:fig2}
\end{figure}

If $conc_u$ is true at the beginning of round $t$ (see figure \ref{fig:fig1}),
then every node $j \in In_u(t-k+i:t)$ verifies $c_j(t-k+i) = true$ and $c_j(t-k+i) \equiv i [k]$ (see lemma \ref{lem:conc-safety}).
Ultimately, every node in $In_u(t-k:t)$ (including the center) is congruent with 0 in round $t-k$.
In opposition, if some node $j \in In_u(t-k:t)$ is not congruent with 0 in round $t-k$,
then the line \ref{line:conc-gossip} guarantees that $conc_u$ will ultimately be false at the beginning of round $t$.

The colored section in the algorithm actually implement an optimization.
For the proof, we will at first consider this optimization disabled.

\begin{algorithm}[htb]
	\DontPrintSemicolon
	\textbf{Initialization:} \;
	\Indp
		$c_u \in \mathds{N}$, initially 0 \;
		$conc_u \leftarrow false$ \;
		$ready_u \leftarrow false$ \;
		$force_u \in \{0, 1, 2\}$, initially 0 \;
		$level_u \in \{0, 1, 2\}$, initially 0 \;
	\BlankLine
	\Indm
	\textbf{At each round $r$:} \;
	\Indp
		send $\langle c_u, conc_u, force_u, ready_u \rangle$ to all  \;
		receive incoming messages from all $v \looparrowright u$ \;
		$conc_u \leftarrow \forall v \looparrowright u, conc_v \wedge c_v \equiv c_u [k]$ and no null received \; \label{line:conc-gossip}
		$ready_u \leftarrow \forall v \looparrowright u, ready_v$ \; \label{line:ready-gossip} 
		$force_u \leftarrow max \{force_v, v \looparrowright u \}$ \;\label{line:force}
		$c_u \leftarrow 1+ min \{c_v, v \looparrowright u \wedge force_v = force_u\}$ \;\label{line:min-z-end} 
		\If{$c_u \equiv 0 [k] \wedge (conc_u \textcolor{teal}{\vee force_u = 2)}$}{ \label{line:cond-levelup} 
			\If{$level_u = 0$}{ \label{line:level1up}
				$level_u \leftarrow 1$ \;
				$force_u \leftarrow 1$ \; \label{line:force2}
				$c_u \leftarrow 0$ \; \label{line:force3}
			}
			\If{$\textcolor{teal}{force_u = 2 \vee}~ready_u$}{ \label{line:cond-firing}
				$\color{teal} force_u \leftarrow 2$ \;
				$level_u \leftarrow 2$ \;
				$c_u \leftarrow 0$ \; 
			}
			$conc_u \leftarrow true$ \; \label{line:conc-true}
			$ready_u \leftarrow level_u > 0$ \; \label{line:init-ready}
		}
	\Indm
\caption{The $SyncMod$ algorithm} 
\end{algorithm}

We consider an execution of the $SyncMod$ algorithm.
We note $c_u(t), conc_u(t), \dots$ the value of the $c, conc, \dots$ variable of node $u$ in round $t$, if $u$ is active in round $t$.
We now prove that this execution verifies the safety and liveness properties of the $mod-k$-synchronization problem.

\begin{lem} \label{lem:conc-safety}
	Let $i$ be an integer verifying $i \leq k$, $t$ a round, and $u$ a node.
	If the condition $c_u \equiv 0 [k] \wedge conc_u$ is true in line \ref{line:cond-levelup} in round $t+k$, then $c_\cent(t+i) \equiv i [k]$.
\end{lem}
\begin{proof}
	We denote $(\cent = w(t+i), \dots, w(t+k) = u)$ the path between $\cent$ and $u$.
	This path must exist according to $\mathcal{P}_{k-centered}$.
	We can now show using a backward induction on this path that every node $w(t+j)$ on this path is active and verifies $c_{w(t+j)}(t+j) \equiv j [k]$ and $conc_{w(t+j)}(t+j)$.

	The base case is the hypothesis of the lemma.
	For the induction case, we assume that $i \leq j < k$, and $c_{w(t+j+1)}(t+j+1) \equiv j+1 [k]$ and $conc_{w(t+j+1)}(t+j+1)$.
	By the definition of a path, we know that $w(t+j)$ sent a message $\langle x, conc_{w(t+j)}(t+j), *, * \rangle$ to $w(t+j+1)$ in round $t+j+1$.
	If $j = 1$, we get directly from line \ref{line:conc-true} that $conc_{w(t+j)}(t+j)$.
	Otherwise, from line \ref{line:conc-gossip}, we get that $w(t+j)$ is active and $conc_{w(t+j)}(t+j)$. Moreover, the received messages are concordant.
	Then, from line \ref{line:min-z-end}, we get $c_{w(t+j+1)}(t+j+1) \equiv x+1 [k]$, then $c_{w(t+j)}(t+j) \equiv x \equiv j [k]$.
\end{proof}

\noindent Using the exact same reasoning, we can prove the following lemma.
\begin{lem} \label{lem:conc-safety-bis}
	If $conc_u \wedge ready_u \wedge c_u \equiv 0 [k]$ is true in line \ref{line:cond-levelup} in round $t+k$, then $level_\cent(t) \geq 1$.
\end{lem}
\begin{proof}
	We consider a path $(\cent = w(t), \dots, w(t+k) = u)$. Such a path must exist because we assumed that $\mathcal{P}_{k-centered}$.
	We can show using a backward induction on this path that any node on this path is active and verifies $conc_{w(t+i)} \wedge ready_{w(t+i)}$.
	We eventually get $ready_\cent(t)$. The line \ref{line:init-ready} proves the lemma.
\end{proof}

\begin{lem} \label{lem:no-close-level2}
	If $\cent$ reaches level 1 in round $t+k$, no node can level up in any round between $t+k+1$ and $t+2k-1$.
\end{lem}
\begin{proof}
	We assume that some node $u$ levels up in round $t+k+i$ where $i \in \{1, \dots, k-1\}$.
	Applying the lemma \ref{lem:conc-safety} to $u$ and $\cent$, we get respectively $c_\cent(t+i) \equiv 0 [k]$ and $c_\cent(t+i) \equiv i [k]$.
	We use the path between $\cent$ and $u$ in the interval $[t+i,t+k+i]$ and the path between $\cent$ and $\cent$ in the interval $[t+i,t+k]$ respectively.
	These paths are guaranteed to exist because of $\mathcal{P}_{k-centered}$ and the assumption of existence of self-loops respectively.
	We get a contradiction from $i \equiv 0 [k]$.
\end{proof}

\begin{lem} \label{lem:ready-safety}
	If node $u$ reaches level 2 in round $t+i$, then $\cent$ must have reached level 1 in a previous round $t$. Moreover $c_u(t+i) \leq i$.
\end{lem}
\begin{proof}
	The first part of the lemma results from lemma \ref{lem:conc-safety-bis}. We now prove the second part.
	The lemma \ref{lem:no-close-level2} tells us that $i \geq k$.
	We consider a path $(\cent = w(t), w(t+1) = \cent, \dots, w(t+i-k) = \cent, \dots, w(t+i) = u)$ from $\cent$ to $u$ in the interval $[t, t+i]$. 
	Using a simple backward induction on this path, we can show that for any $j \in \{i-k, \dots, i\}$,
	the node $w(t+j)$ is active, is at least in level 1, and verifies $ready_{w(t+j)}(t+j)$ and $conc_{w(t+j)}(t+j)$.
	The base case relies on the lines \ref{line:cond-firing} and \ref{line:cond-levelup}. The induction case relies on lines \ref{line:conc-gossip} and \ref{line:ready-gossip}.

	Using a simple forward induction on this path, we can show that any $w(t+j)$ on this path verifies $force_{w(t+j)}(t+j) \geq 1$ and $c_{w(t+j)}(t+j) \leq j$.
	The base case relies on the lines \ref{line:force2} and \ref{line:force3}. The induction case relies on lines \ref{line:force} and \ref{line:min-z-end}.
\end{proof}

\begin{lem} \label{lem:safety-force}
	If $c_u(t+i) = i$, then some node must have reached level $force_u(t+i)$ in round $t$.
\end{lem}
\begin{proof}
	Without loss of generality, we assume $force_u(t+i) = 1$.
	We show this lemma by induction over $i$.
	For the base case, we have to show that the line \ref{line:force2} was executed by $u$ in round $t$.
	This must be true, otherwise the fact that $c_u(t) = 0$ could not be explained.

	For the induction case, we assume that $c_u(t+i+1) = i+1$ and $force_u(t+i+1) = 1$.
	Then, a node $v$ must have sent a message which looks like $\langle i, *, 1, * \rangle$ (see lines \ref{line:force} and \ref{line:min-z-end}).
	The proof can now be concluded thanks to the induction hypothesis.
\end{proof}

\begin{lem} \label{lem:later-level1}
	If $\cent$ reached level 1 in round $t$, whereas $u$ reached level 1 in round $t+i$, then $i \equiv 0 [k]$. 
\end{lem}
\begin{proof}
	By contradiction, we consider the first node $u$ which reaches level 1 in round $t+i$ with $i \not\equiv 0 [k]$.
	The case $i < k$ is impossible according to lemma \ref{lem:no-close-level2}.

	In the case $i > k$, since $conc_u(t+i)$ is true, there exist an active path from $\cent$ in round $t$ to $u$ in round $t+i$.
	On this path $(\cent = w(t), \dots, w(t+i) = u)$, we can show by a simple induction that, for any $0 \leq j \leq i$, we have $c_{w(t+j)}(t+j) \leq c_\cent(t)+j$.
	Since we assumed that $i \not\equiv 0[k]$, we have $c_u(t+i) \neq c_\cent(t)+i$.
	Then, using lemma \ref{lem:safety-force} gives us that a node $v$ must have reached level 1 later than $\cent$, with $c_v(t+i) \equiv c_u(t+i) [k]$.
	This contradicts the fact that $u$ was the first non-congruent level 1 node.
\end{proof}

\begin{thm} \label{lem:safety} 
	The algorithm is safe.
\end{thm}
\begin{proof}
	We assume that $u$ and $v$ reach level 2 in round $t+i$ and $t+j$ respectively.
	According to lemma \ref{lem:ready-safety}, $\cent$ must have reached level 1 in a previous round $t$.
	Moreover $c_u(t+i) \leq i$ and $c_v(t+j) \leq j$.
	According to lemma \ref{lem:safety-force}, there must exist nodes $w$ and $w'$ which reached level 1 in rounds $t+i-c_u(t+i)$ and $t+j-c_u(t+j)$ respectively.
	According to lemma \ref{lem:later-level1}, we have $i-c_u(t+i) \equiv 0 [k]$ and $j-c_u(t+j) \equiv 0 [k]$. 
	Since we have $c_u(t+i) \equiv 0 [k]$ and $c_v(t+j) \equiv 0 [k]$, we get $i \equiv j [k]$. That proves safety.
\end{proof}

\begin{lem}
	Every node eventually reaches level 1.
\end{lem}
\begin{proof}
	Let $Z_r$ be the set of level 0 nodes in round $r$.
	Let $V_r$ be the set of values of $Z_r$.
	We consider the sequence $h_r = |Z_r| + max~V_r - min~V_r$.
	We have to show that $Z_r$ eventually becomes empty, in other words $(h_r)$ should eventually be undefined.
	By contradiction, we assume that $(h_r)$ is always defined.
	Let $s^{max}$ the first round in which every node is active.
	If $r \geq s^{max}$, we can show that if $V_r \subseteq \{t, \dots, t+i\}$, then $V_{r+1} \subseteq \{t+1, \dots , t+i+1\}$ (see line \ref{line:min-z-end}).
	That proves that $(h_r)$ cannot grow from $s^{max}$.
	Then, there exists a round $t$ from which the set $Z_r$ is stabilized and $max~V_r - min~V_r$ is constant.
	We consider the set $Z_r^{max}$, which contains every nodes $u$ such that $c_u(r) = max~V_r$.
	For any $r \geq t$, we can show that $Z_{r+1}^{max} = \{u \in Z_r^{max}, HO(u, r+1) \subseteq Z_r^{max}\}$. That is a consequence of line \ref{line:min-z-end}.
	Then, this sequence of set is decreasing from $t$. Moreover, it cannot become empty, otherwise $max~V_r - min~V_r$ would decrease (we assumed that this value is stable from t).
	Then we consider the non-empty set $M = \bigcap\limits_{r \geq t} Z_r^{max}$.
	Such a set is a subset of the system, which from $t$, never receive any message from the outside, and all hold the same value.
	From the round $t+k$, the line \ref{line:conc-gossip} implies that any $u \in M$ must hold a true $conc$ variable.
	Then, every node in $M$ must reach level 1 before round $t+2k$. Hence $M \cap Z_{t+2k} = \emptyset$.
	We get a contradiction with the definition of $M$.
\end{proof}

\begin{lem}
	The algorithm is live
\end{lem}
\begin{proof}
	We consider the round $t$ in which every node have reached level 1.
	For any node $u$, we consider the path $(\cent = w(t), \dots, w(t+k) = u)$ from $\cent$ to $u$ in the interval $[t, t+k]$.
	Every node is now active.
	By a simple forward induction on this path, we can prove that $c_u(t+k) \leq c_\cent(t)+k$.
	With lemma \ref{lem:later-level1}, we can show that from round $t+k$, every values in the system are congruent modulo $k$.
	Then, from $t+2k$, the variables $ready$ and $conc$ must be true in all nodes.
	Every node must have reached level 2 in round $t+3k$.
\end{proof}

% section_cons (do not modify this comment)
\section{Use-cases of $mod-k$-synchronization}

\subsection{Algorithms without safety assumption}

Let us consider a given algorithm $A$, which can solve a problem $\mathcal{A}$ when the starts are synchronous.
The correctness of $A$ may depend on some assumptions.
Usually, the assumptions required for safety are expressed as invariants on the dynamic graph: $\forall r \in \mathds{N}, P_{saf}(\mathds{G}_r)$.
Whereas the assumptions required for liveness are expressed as infinitely often verified predicates on the dynamic graph: $\forall r \in \mathds{N}, \exists r' > r, P_{liv}(\mathds{G}_{r'})$.
The case where no invariant is required for safety is easier to deal with. At first we focus on this case.

We assume that $A$ is structured as $k$ rotating phases, which means that $A$ needs $mod-k$-synchronization.
We construct the algorithm $SynchMod_k \lozenge A$ in the following way:
we consider a node $u$. 
\begin{enumerate}
	\item At first, $u$ is passive, and sends null messages, according to the model.
	\item From round $s_u$, the node $u$ is active. It starts the $SyncMod$ algorithm. It sends and receives messages according to the $SyncMod$ algorithm and ignore the messages related to $A$.
	\item In round $\tf_u$, the node $u$ fires. From this round, $u$ executes $SyncMod$ in parallel with $A$. Both $A$ and $SyncMod$ send and receive messages according to their pseudo-code.
		In some cases, $u$ may receive from a neighbor $v$ a message related to $SyncMod$, and no message related to $A$. Then $u$ can guess that $v$ has not fired yet.
		The $A$ instance of $u$ interpret that as a null message received from $v$.
\end{enumerate}

We now wonder whether $SynchMod_k \lozenge A$ solves $\mathcal{A}$ with asynchronous starts, and how $A$ should deal with null message.
In the case without required invariant, $A$ could assimilate null messages as lost messages,
and we could reasonably expect that $SynchMod_k \lozenge A$ solves $\mathcal{A}$ with asynchronous starts.
Indeed, the drop of the null messages in $A$ is equivalent with the drop of some edges in the dynamic graph.
The safety proof without invariant is not affected by the modification of the dynamic graph, and should be easily extended from synchronous starts system to asynchronous starts system.
Moreover, if we assume that no node remains passive forever, no edge is dropped in the dynamic graph beyond a certain round.
Then, the liveness proof with synchronous starts should be still valid if applied from that round.

Some notable examples of algorithms which can be adapted with this approach include the LastVoting \cite{CBS09} algorithm (an round-based adaptation of Paxos \cite{paxos}) which solves consensus,
and the ThreePhaseCommit \cite{BT93} algorithm, which solves the database commit problem.

\subsection{Algorithms with safety assumption}

When the safety proof of an algorithm relies on some invariant, the drop of edges in the dynamic graph might break the safety proof.
A possible fix could consist in changing the way the algorithm $A$ deals with null message. This must be done in a case-by-case basis.
We exemplify that with an adaptation of the UniformVoting \cite{CBS09} \cite{Ben83} algorithm.


\begin{algorithm}[htb]
	\DontPrintSemicolon
	\textbf{Initialization:} \;
	\Indp
		$x_u := v_u$ ~~~~~~~~\{\emph{$v_u$ is the initial value of $p$}\} \;
		$vote_u \in V\cup\{ ? \}$, initially $?$ \;
		$phase_u = true$ ~~~~~~\{\textit{variable which organises the two-phase rotation}\} \;
	\BlankLine
	\Indm
	\textbf{At each round $r$:} \;
	\Indp
		\If{$phase_u$}{
			send $\langle x_u , vote_u \rangle$ to all
		}
		\Else{send $\langle x_u \rangle$ to all}
		receive incoming messages \;
		\If{$phase_u$}{
			\If{a node voted for $v$}{
				$x_u:= v$ \label{line:adopt_vote}
			}
			\Else{
				$x_u :=$ smallest  $w$ from  $\langle w , ? \rangle$ received \label{line:min_vote} \;
				\If{every node voted for $v$, none sent null}{ \label{line:cond1}
					$DECIDE(v)$ \;
					$vote_u :=\ ?$ \;
				}
			}
		}
		\Else{
			$ x_u :=$ minimum value received (excluding null) \label{line:min_val} \;
			\If{every node sent $v$, none sent null}{ \label{line:cond2}
				$vote_u := v$
			}
		}
		$phase_u := \neg phase_u$ \;
	\Indm
\caption{The {\em AdaptedUniformVoting} algorithm}
\end{algorithm}

This pseudo-code is almost identical to the pseudo-code used in the systems with synchronous starts.
However, you can see that in lines \ref{line:cond1} and \ref{line:cond2}, the effect of the null messages is precised.
In that case, the null messages are not dropped. They prevent the nodes from voting and deciding.

It is possible to prove the following theorem:

\begin{thm}
	The $SynchMod_4 \lozenge AdaptedUniformVoting$ algorithm solves the consensus problem under the condition of a centered dynamic graph and a complete activation schedule.
\end{thm}

The proof of validity and agreement for UniformVoting given in \cite{CBS09} can easily be transposed to \newline $SynchMod_4 \lozenge AdaptedUniformVoting$.
The proof of termination, which is radically different, is detailed below.

\begin{proof}
	We consider an execution of $SynchMod_4 \lozenge AdaptedUniformVoting$.
	Let $r$ be the round in which $\cent$ fires.
	In round $r+1$, the $AdaptedUniformVoting$ algorithm is started by $\cent$.

	We claim that the sequence $(x_\cent(r+i+1))_{i \in \mathds{N}}$ is decreasing.
	\begin{enumerate}
		\item If $i+2$ is odd, the line \ref{line:min_val} guarantees that $x_\cent(r+i+2) \leq x_\cent(r+i+1)$.
		\item If $i+2$ is even and a node $u$ voted for $v$, the only possibility is $v = x_\cent(r+i+1)$. This is because $\cent$ sent $x_\cent(r+i+1)$ to $u$ in round $r+i+2$.
			Then $x_\cent(r+i+2) = x_\cent(r+i+1)$.
		\item If $i+2$ is even and no node voted, the line \ref{line:min_vote} guarantees that $x_\cent(r+i+2) \leq x_\cent(r+i+1)$.
	\end{enumerate}
	That proves the claim.

	Since this series is decreasing, and the set of initial decision values is finite, it must reach a minimum.
	We consider the earliest round $r_0 \geq \phi^{max}$ in which every node have already fired and the series has stabilized to $v$.

	Without loss of generality, we assume that the round $r_0+1$ is a round of exchange of value (i.e. $\forall u \in \Pi, \neg phase_u(r_0)$).
	Since $x_\cent(r_0+1) = x_\cent(r_0)$, we know that $\cent$ only receives messages containing $v$ in round $r_0+1$ (see line \ref{line:min_val}).
	Then $\cent$ must vote $v$ in round $r_0+2$ (see line \ref{line:cond2}).
	Then every node must adopt $v$ in round $r_0+2$ (see line \ref{line:adopt_vote}).
	Then, in round $r_0+3$ every node must send $v$ to all.
	Then, in round $r_0+3$ every node can only receive $v$.
	Then, in round $r_0+3$ every node must vote for $v$ (see line \ref{line:cond2}).
	Then, in round $r_0+4$ every node must decide $v$.
	That proves termination.
\end{proof}

\subsection{$mod-n$-synchronization and coordinated algorithms}

Some algorithms like Paxos rely on the existence of a shared coordinator in each round.
A simple implementation consists in setting a rotating coordinator: 
each node holds the list of nodes. In the first round, the chosen coordinator is the first node in the list.
In the $i^{th}$ round, the chosen coordinator is the $i~mod~n^{th}$ node on the list.
This works out-of-the box when the starts are assumed to be synchronous.
However, when the starts are asynchronous, a prior $mod-n$-synchronization is required, where $n$ is the number of nodes in the shared list.
This is another typical use case of the $SyncMod$ algorithm.

\subsection{A much simpler approach ?}

In the case of the problem of consensus, we have mentioned in a previous paragraph the possibility to use Paxos.
Since we only consider synchronous systems, much simpler algorithms like FloodSet \cite{Lyn96} exists.
As mentioned in \cite{CDDS85}, the FloodSet algorithm can be adapted to solve consensus in a system with asynchronous starts.
Using a variant of the firing squad algorithm (called $AdaptedFiringSquad_f$ here),
where the nodes hold a counter $c_u \in \mathds{N}$, and fire when they reach an upper bound $f$ on the number of failure.
Using $AdaptedFiringSquad_f \lozenge FloodSet$, we get a simple consensus algorithm.
This approach has some shortcomings, though.
Firstly, the nodes have to "know" an shared upper bound on the number of failures.
Then, only the simplest form of failure is supported: the crash-failures.
More importantly, this method achieves \textit{non-uniform} consensus: only the non-crashed nodes are required to decide.

% section_conclusion (do not modify this comment)
\section{Conclusion and future work}

As any complex reasoning by cases, the correctness proof  of the $SyncMod$   algorithm, 
	and more specifically the proof of the liveness property, is very error prone. 
This is a typical example of the relevance of formal verification for distributed algorithms. 
Indeed, in a later work~\cite{}, we used the interactive theorem prover Isabelle \cite{Merz12} to encode the complete proof 
	of Theorem~\ref{thm:k>2}, and thus obtained a certificate for  $SyncMod$\!\!'s correctness when $k$ is greater than 2.
	
Since $mod-2$-synchronization is reducible to $mod-4$-synchronization,
	 our algorithm solves the $mod-k$-synchronization problem for any positive integer~$k$
	 in the class of  dynamic  graphs with a fixed center.
This class of dynamic graphs plays a crucial role regarding benign failures as it captures 
	the synchronous model with at most $n-1$ faulty senders, including the one with at most $n-1$ crashes.
In the wilder context of dynamic graphs, a natural question is whether the problem is still solvable 
	under weaker connectivity assumptions, in particular, in the class of dynamic graphs with a fixed root, 
	i.e., with a time-varying spanning tree at each round rooted at a fixed node.

% end_section (do not modify this comment)

\printbibliography

\end{document}
