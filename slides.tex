\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[noend]{sources-Heard-Of/distribalgo}
\usepackage{algorithm}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{amsthm}
\usepackage{dsfont}
\usepackage{stmaryrd}

\title{Vérification et preuve formelle dans le modèle Heard-Of}
\date{8 septembre 2020}
\author{Louis Penet de Monterno - stage encadré par Bernadette Charron-Bost}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Notations}
\begin{itemize}
	\item $\Pi$ désigne l'ensemble des processus.
	\item $n$ désigne le nombre de processus.
	\item $HO(p, r)$ désigne l'ensemble des processus ayant pus communiquer avec $p$ au round $r$.
	\item $\mathds{G}_r$ désigne le graphe de communication au round $r$.
	\item $\mathcal{A}_r$ désigne l'ensemble des processus actifs au round $r$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Quelques prédicats}
\begin{itemize}
\item $\mathcal{P}_{complet} \equiv \forall r \in \mathds{N}, \forall p \in \Pi, HO(p, r) = \Pi$
\item $\mathcal{P}_{\xi-nek} \equiv \exists \xi \in \Pi, \forall r \in \mathds{N}, \forall p \in \Pi, \xi \in HO(p,r)$
\item $\mathcal{P}_{nek} \equiv \forall r \in \mathds{N}, \exists \xi \in \Pi, \forall p \in \Pi, \xi \in HO(p,r)$
\item $\mathcal{P}_{non-inf} \equiv \exists r \in \mathds{N}, \mathcal{A}_r = \Pi$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Problème du consensus}
\begin{description}
	\item[Intégrité :] La valeur décidée par chaque processus est l'une des valeurs initiales.
	\item[Accord :] Tous les processus décident la même valeur.
	\item[Terminaison :] Tous les processus décident en temps fini.
\end{description}
\end{frame}

\begin{frame}
\frametitle{Algorithme One-Third rule}
\begin{algorithm}[H]
\algsetup{linenosize=\small}
\scriptsize
\begin{distribalgo}[1]
\BLANK
\INDENT{\textbf{Initialisation:}}
	\STATE $x_p := v_p$ \COMMENT{  $v_p$ est la valeur initiale de $p$ }
	\STATE $dec_p := \bot$ 
\ENDINDENT
\BLANK
\INDENT{\textbf{Round $r$:}}
	\INDENT{$S_p:$}
		\STATE envoyer $\langle x_p \rangle$ à tous les processus
	\ENDINDENT
	\BLANK
	\INDENT{$T_p(M):$}
		\IF{$|Sup(M)| > 2 n/3 $}
			\STATE $x_p := min \{\widetilde{M}^{-1} (max \widetilde{M})\}$ \COMMENT{ \scriptsize valeur minimale parmi les plus fréquentes}
			\IF{$\widetilde{M}(x_p) > 2 n/3$} 
				\STATE $dec_p := x_p$ \COMMENT{plus de $2 n/3$ des valeurs reçues valent $x_p$}
			\ENDIF
		\ENDIF
	\ENDINDENT
\ENDINDENT \BLANK
\caption{L'algorithme {\em One-Third rule}} \label{algo:R}
\end{distribalgo}
\end{algorithm}
\end{frame}

\begin{frame}
\frametitle{Algorithme One-Third rule}
On définit les prédicats :
\begin{itemize}
	\item $P_{S-unif-\infty} \equiv$ il existe infiniment souvent un sous-ensemble dont les membres s'entendent mutuellement exclusivement.
	\item $P_{supermaj-\infty} \equiv$ chaque processus entend infiniment souvent une supermajorité de voisins entrants.
\end{itemize}
On obtient alors :
\begin{theorem}
	L'algorithme "One-Third rule" résout  le consensus lorsque les processus connaissent la taille du réseau,
	et lorsque les prédicats $P_{S-unif-\infty}$ et $P_{supermaj-\infty}$ sont vérifiés.
\end{theorem}
\end{frame}

\begin{frame}
\frametitle{Algorithme Uniforme Voting}
\begin{algorithm}[H]
\tiny{
\begin{distribalgo}[1]
\begin{tabular}{ll}
\begin{minipage}{33em}
\INDENT{\textbf{Initialisation:}}
  \STATE $x_p := v_p$ ~~~~~~~~\{\emph{\tiny $v_p$ est la valeur initiale $p$}\}
  \STATE $vote_p \in V\cup\{ ? \}$, initialement $?$
  \STATE $phase_p = true$

\ENDINDENT
\INDENT{\textbf{Round $r$:}}
	\INDENT{$S_p^r:$}
		\IF{$phase_p$}
			\STATE envoyer $\langle x_p , vote_p \rangle$ à tous les processus
		\ELSE
			\STATE envoyer $\langle x_p \rangle$ à tous les processus
			\ENDIF
	\ENDINDENT
	\INDENT{$T_p^r:$}
		\IF{$phase_p$}
			\IF{$M(q) = \langle v, v \rangle$}
				\STATE $x_p:= v$ ~~~~~~~~\{\tiny un vote reçu\}
			\ELSE
				\STATE $x_p :=$ smallest  $w$ from  $\langle w , ? \rangle$ received
			\ENDIF
			\IF{$M(\Pi) = \{ \langle v, v \rangle \}$}
				\STATE $DECIDE(v)$ ~~~~~~~~\{\tiny $p$ ne reçoit que des votes identiques\}
			\ENDIF
			\STATE $vote_p :=\ ?$
		\ELSE
			\STATE $ x_p := min M(\Pi) \setminus \{nil\}$ ~~~~~~~~\{\tiny plus petites valeur reçue\}
			\IF{$M(\Pi) = \{v\}$}
				\STATE $vote_p := v$ ~~~~~~~~\{\tiny toute les valeurs reçues identiques, aucun nil\}
			\ENDIF
		\ENDIF
		\STATE $phase_p := \neg phase_p$
	\ENDINDENT
\ENDINDENT
\end{minipage}
\end{tabular}
\caption{L'algorithme {\em Uniforme Voting}}
\label{unifvotfig}
\end{distribalgo}
}
\end{algorithm}
\end{frame}

\begin{frame}
\frametitle{Algorithme du Firing-Squad}
\begin{algorithm}[H]
\scriptsize{
\begin{distribalgo}[1]
\INDENT{\textbf{Initialisation:}}
	\STATE $x_p \in \mathds{N}$, initialement 0
\ENDINDENT
\INDENT{\textbf{Round $r$:}}
	\INDENT{$S_p:$}
		\STATE envoyer $\langle x_p \rangle$ à tous les processus
	\ENDINDENT
	\BLANK
	\INDENT{$T_p(M):$}
		\IF{$nil \in M(\Pi)$}
			\STATE $x_p := 0$
		\ELSE
			\STATE $x_p := 1 + min~M(\Pi)$
		\ENDIF
		\IF{$x_p > D$}
			\STATE $FIRE()$
		\ENDIF
	\ENDINDENT
\ENDINDENT 
\caption{L'algorithme du {\em Firing-Squad}} \label{algo:R}
\BLANK
\end{distribalgo}
}
\end{algorithm}
\end{frame}

\begin{frame}
\frametitle{Algorithme SyncMod}
\begin{algorithm}[H]
\tiny{
\begin{distribalgo}[1]
\INDENT{\textbf{Initialisation:}}
	\STATE $x_p \in \mathds{Z}/k\mathds{Z}$
	\STATE $try_p = true$
	\STATE $fire_p = false$
	\STATE $started_p = false$
\ENDINDENT 
\INDENT{\textbf{Round $r$:}}
	\INDENT{$S_p:$}
		\IF{$started_p$}
			\STATE envoyer $\langle x_p \rangle$ à tous les processus
		\ELSE
			\STATE envoyer $\bot$ à tous les processus
		\ENDIF
	\ENDINDENT
	\INDENT{$T_p(M):$}
		\STATE $started_p = true$
		\IF{$M(\Pi) = \{k\}$}
			\STATE $fire_p = true$ ~~~~\COMMENT{\tiny tous les messages reçus valent $k$, aucun $nil$, l'algorithme fait feu}
		\ENDIF
		\IF{$M(\Pi) \setminus \{nil, \bot\} = \{v\}$}
			\STATE $x_p = v+1~mod~k$ ~~~~\COMMENT{\tiny si tous les messages ont la même valeur, s'aligner}
		\ELSIF{$try_p \wedge k \notin M(\Pi)$}
			\STATE $try_p = false$ ~~~~\COMMENT{\tiny si plusieurs messages discordants, faire tentative de synchronisation forcée}
			\STATE $x_p = k$
		\ELSE
			\STATE $x_p = 1$ ~~~~\COMMENT{\tiny si un k a été reçu, toujours s'aligner}
		\ENDIF
	\ENDINDENT
\ENDINDENT 
\caption{L'algorithme {\em SyncMod}} \label{algo:R}
\end{distribalgo}
}
\end{algorithm}
\end{frame}

\begin{frame}
\frametitle{Algorithme Uniforme Voting}
\begin{theorem}
	L'algorithme "Uniforme Voting" exécuté en série à la suite de l'algorithme "SyncMod" avec $k = 4$
	résout le consensus lorsque les prédicats $\mathcal{P}_{\xi-nek}$ et $\mathcal{P}_{non-inf}$ sont vérifiés.
\end{theorem}
\end{frame}

\end{document}
